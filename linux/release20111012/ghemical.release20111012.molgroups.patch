diff -Nur ./libghemical-3.0.0.original/src/Makefile.in ./libghemical-3.0.0/src/Makefile.in
--- ./libghemical-3.0.0.original/src/Makefile.in	2023-02-11 12:52:01.934245352 +0000
+++ ./libghemical-3.0.0/src/Makefile.in	2023-02-12 20:59:06.455845851 +0000
@@ -302,6 +302,7 @@
 	libghemicaldefine.h \
 	libghemical-features.h \
 	local_i18n.h \
+	long_stream.h \
 	typedef.h \
 	v3d.h \
 	atom.h \
diff -Nur ./libghemical-3.0.0.original/src/long_stream.h ./libghemical-3.0.0/src/long_stream.h
--- Null
+++ ./libghemical-3.0.0/src/long_stream.h	2023-02-12 14:14:00.696350257 +0000
@@ -0,0 +1,125 @@
+﻿#pragma once
+#include <string>
+#include <iostream>
+#include <fstream>
+
+//---------------------------------------------------
+// пространство имен, в которое заносятся детали реализации
+namespace detail {
+   //http://forum.sources.ru/index.php?showtopic=83356&view=showall
+   //http://www.tdoc.ru/c/programming/cpp/cpp-traits-page4.html
+   template <typename num_type, typename state_type = std::mbstate_t>
+   class pos_type_t {
+      typedef pos_type_t<num_type, state_type> my_type;
+
+      num_type    m_pos;
+      state_type  m_state;
+
+      static state_type initial_state;
+
+   public:
+      // конструкторы
+      pos_type_t(std::streampos off) : m_pos(off), m_state(initial_state) {}
+      pos_type_t(num_type off = 0) : m_pos(off), m_state(initial_state) {}
+      pos_type_t(state_type state, num_type pos) : m_pos(pos), m_state(state) {}
+
+      // получение состояния потока
+      state_type state() const {
+         return(m_state);
+      }
+
+      // установка состояния потока
+      void state(state_type st) {
+         m_state = st;
+      }
+
+      // получение позиции
+      num_type seekpos() const    {
+         return(m_pos);
+      }
+
+      // оператор преобразования
+      operator num_type() const {
+         return(m_pos);
+      }
+
+      // далее идут операторы, которые осуществляют арифметические операции
+
+      num_type operator- (const my_type& rhs) const {
+         return(static_cast<num_type>(*this) - static_cast<num_type>(rhs));
+      }
+
+      my_type& operator+= (num_type pos) {
+         m_pos += pos;
+         return(*this);
+      }
+
+      my_type& operator-= (num_type pos) {
+         m_pos -= pos;
+         return(*this);
+      }
+
+      my_type operator+ (num_type pos) const {
+         my_type tmp(*this);
+         return(tmp += pos);
+      }
+
+      my_type operator- (num_type pos) const {
+         my_type tmp(*this);
+         return(tmp -= pos);
+      }
+
+      // операторы сравнения
+
+      bool operator== (const my_type& rhs) const {
+         return(static_cast<num_type>(*this) == static_cast<num_type>(rhs));
+      }
+
+      bool operator!= (const my_type& rhs) const {
+         return(!(*this == rhs));
+      }
+   };
+   //---------------------------------------------------
+   // статическая константа, которая обозначает начальное состояние
+   template <typename num_type, typename state_type>
+   state_type pos_type_t<num_type, state_type>::initial_state;
+}
+//---------------------------------------------------
+// наконец-то наш класс свойств:
+template <typename char_t, typename long_pos_t>
+struct long_pointer_traits : public std::char_traits<char_t> {
+   // тип, используемый для представления позиции в потоке
+   // определение pos_type через наш только что написанный класс
+   typedef detail::pos_type_t<long_pos_t> pos_type;
+
+   // тип, используемый для представления
+   // смещений между позициями в потоке
+   // определение off_type через тип, переданный во 2 аргументе шаблона
+   typedef long_pos_t off_type;
+};
+
+
+//---------------------------------------------------
+// вводим тип "длинного" файла
+// "длинные" типы:
+
+typedef std::basic_filebuf <char, long_pointer_traits<char, int64_t> > long_filebuf;
+typedef std::basic_ifstream<char, long_pointer_traits<char, int64_t> > long_ifstream;
+typedef std::basic_ofstream<char, long_pointer_traits<char, int64_t> > long_ofstream;
+typedef std::basic_fstream <char, long_pointer_traits<char, int64_t> > long_fstream;
+
+typedef std::basic_string  <char, long_pointer_traits<char, int64_t> > long_string;
+
+//---------------------------------------------------
+/*int main(int argc, char** argv) {
+long_ifstream infile(argv[1], std::ios::binary);
+infile.seekg(0L, std::ios::end);
+long_ifstream::pos_type nSize = infile.tellg();
+std::cout << nSize;
+return(0);
+
+long_ifstream infile(strFileName, std::ios::binary);
+long_string res;
+std::getline(infile, res);
+}*/
+
diff -Nur ./libghemical-3.0.0.original/src/model.cpp ./libghemical-3.0.0/src/model.cpp
--- ./libghemical-3.0.0.original/src/model.cpp	2023-02-11 20:25:03.717681261 +0000
+++ ./libghemical-3.0.0/src/model.cpp	2023-02-12 20:39:17.823870518 +0000
@@ -51,8 +51,10 @@
 
 #include <cstring>
 #include <iomanip>
+#include "long_stream.h"
 #include <sstream>
 #include <strstream>
+#include <map>
 using namespace std;
 
 #ifdef WIN32
@@ -159,7 +161,8 @@
 	traj_num_atoms = NOT_DEFINED;
 	total_traj_frames = NOT_DEFINED;
 	current_traj_frame = NOT_DEFINED;
-	trajectory_version = 14;
+	trajectory_version = 17;
+	frame_save_frq = 10000;
 	
 	verbosity = 3;
 	
@@ -1151,6 +1154,252 @@
 /*##############################################*/
 /*##############################################*/
 
+void model::MakeMoleculesGroups(std::list<struct molgroup>& molgroups)
+{
+	iter_bl itb;
+
+	i32s n1, nmol;
+	bool iscarbon1;
+	bool iscarbon2;
+	i32s index1, index2;
+	std::map<i32s, molecule>::iterator itmol;
+	std::map<i32s, molecule>::iterator itmol1;
+	std::map<i32s, molecule>::iterator itmol2;
+
+	UpdateIndex();
+
+	std::map<i32s, molecule> mols;
+
+	for (itb = this->GetBondsBegin();
+		itb != this->GetBondsEnd();
+		++itb)
+	{
+		atom * at1 = (* itb).atmr[0];
+		atom * at2 = (* itb).atmr[1];
+
+		iscarbon1 = 6 == at1->el.GetAtomicNumber();
+		iscarbon2 = 6 == at2->el.GetAtomicNumber();
+
+		index1 = at1->index;
+		index2 = at2->index;
+
+		i32s found1 = NOT_DEFINED;
+		i32s found2 = NOT_DEFINED;
+
+		for (itmol = mols.begin();
+			itmol != mols.end();
+			itmol++)
+		{
+			std::list<i32s>::iterator it  = (*itmol).second.natoms.begin();
+			std::list<i32s>::iterator end = (*itmol).second.natoms.end();
+			for(; it != end; ++it)
+			{
+				if ((*it) == index1)
+				{
+					found1 = (*itmol).first;
+				}
+				if ((*it) == index2)
+				{
+					found2 = (*itmol).first;
+				}
+			}
+		}
+
+		if (NOT_DEFINED == found1 &&
+			NOT_DEFINED == found2)
+		{
+			i32s id = mols.size();
+			mols.insert(std::pair<i32s, molecule>(id,
+				molecule(iscarbon1 ? 1 : 0, index1)));
+			itmol = mols.find(id);
+			(* itmol).second.natoms.push_back(index2);
+			(* itmol).second.ncarbons += iscarbon2 ? 1 : 0;
+		}
+		else
+		{
+			if (NOT_DEFINED == found1)
+			{
+				i32s id = found2;
+				itmol = mols.find(id);
+				(* itmol).second.natoms.push_back(index1);
+				(* itmol).second.ncarbons += iscarbon1 ? 1 : 0;
+			}
+			if (NOT_DEFINED == found2)
+			{
+				i32s id = found1;
+				itmol = mols.find(id);
+				(* itmol).second.natoms.push_back(index2);
+				(* itmol).second.ncarbons += iscarbon2 ? 1 : 0;
+			}
+		}
+	}
+
+	for (itb = this->GetBondsBegin();
+		itb != this->GetBondsEnd();
+		++itb)
+	{
+		atom * at1 = (* itb).atmr[0];
+		atom * at2 = (* itb).atmr[1];
+
+		iscarbon1 = 6 == at1->el.GetAtomicNumber();
+		iscarbon2 = 6 == at2->el.GetAtomicNumber();
+
+		index1 = at1->index;
+		index2 = at2->index;
+
+		i32s found1 = NOT_DEFINED;
+		i32s found2 = NOT_DEFINED;
+
+		for (itmol = mols.begin();
+			itmol != mols.end();
+			itmol++)
+		{
+			std::list<i32s>::iterator it  = (*itmol).second.natoms.begin();
+			std::list<i32s>::iterator end = (*itmol).second.natoms.end();
+			for(; it != end; ++it)
+			{
+				if ((*it) == index1)
+				{
+					found1 = (*itmol).first;
+				}
+				if ((*it) == index2)
+				{
+					found2 = (*itmol).first;
+				}
+			}
+		}
+
+		if (! (NOT_DEFINED == found1 && NOT_DEFINED == found2))
+		{
+			if (found1 < found2 )
+			{
+				itmol2 = mols.find(found2);
+				itmol1 = mols.find(found1);
+
+				// 2 > 1
+				std::list<i32s>::iterator it  = (* itmol2).second.natoms.begin();
+				std::list<i32s>::iterator end = (* itmol2).second.natoms.end();
+				for(; it != end;++it)
+				{
+					(* itmol1).second.natoms.push_back(*it);
+				}
+				(* itmol1).second.ncarbons += (* itmol2).second.ncarbons;
+
+				mols.erase(itmol2);
+			}
+
+			if (found2 < found1 )
+			{
+				itmol2 = mols.find(found2);
+				itmol1 = mols.find(found1);
+
+				// 1 > 2
+				std::list<i32s>::iterator it  = (* itmol1).second.natoms.begin();
+				std::list<i32s>::iterator end = (* itmol1).second.natoms.end();
+				for(; it != end;++it)
+				{
+					(* itmol2).second.natoms.push_back(*it);
+				}
+				(* itmol2).second.ncarbons += (* itmol1).second.ncarbons;
+
+				mols.erase(itmol1);
+			}
+		}
+	}
+
+	for (itb = this->GetBondsBegin();
+		itb != this->GetBondsEnd();
+		++itb)
+	{
+		atom * at1 = (* itb).atmr[0];
+		atom * at2 = (* itb).atmr[1];
+
+		iscarbon1 = 6 == at1->el.GetAtomicNumber();
+		iscarbon2 = 6 == at2->el.GetAtomicNumber();
+
+		index1 = at1->index;
+		index2 = at2->index;
+
+		i32s found1 = NOT_DEFINED;
+		i32s found2 = NOT_DEFINED;
+
+		for (itmol = mols.begin();
+			itmol != mols.end();
+			itmol++)
+		{
+			std::list<i32s>::iterator it  = (*itmol).second.natoms.begin();
+			std::list<i32s>::iterator end = (*itmol).second.natoms.end();
+			for(; it != end; ++it)
+			{
+				if ((*it) == index1)
+				{
+					found1 = (*itmol).first;
+				}
+				if ((*it) == index2)
+				{
+					found2 = (*itmol).first;
+				}
+			}
+		}
+
+		if (! (NOT_DEFINED == found1 && NOT_DEFINED == found2))
+		{
+			at1->id[0] = found1;
+			at2->id[0] = found2;
+		}
+	}
+
+	iter_al it1;
+	bool iscarbon;
+
+	std::map<i32s, molecule> molecules;
+	for (n1 = 0, it1 = this->GetAtomsBegin();
+		 n1 < this->GetAtomCount() && it1 != this->GetAtomsEnd();
+		 n1++, it1++)
+	{
+		nmol = (* it1).id[0];
+		iscarbon = 6 == (* it1).el.GetAtomicNumber();
+		itmol = molecules.find(nmol);
+		if (itmol == molecules.end())
+		{
+			molecules.insert(std::pair<i32s, molecule>((* it1).id[0], molecule(iscarbon ? 1 : 0, n1)));
+		}
+		else
+		{
+			(* itmol).second.ncarbons += iscarbon ? 1 : 0;
+			(* itmol).second.natoms.push_back(n1);
+		}
+	}
+
+	molgroups.push_back(molgroup(GAS));
+	for (itmol = molecules.begin(); itmol != molecules.end(); itmol++)
+	{
+		if ((*itmol).second.ncarbons > 18) // 18 - ncarbons in 5CB
+		{
+			molgroups.push_back(molgroup(MEMBRANE_OR_GLOBULE, (*itmol).second.natoms));
+		}
+		else
+		{
+			std::list<i32s>::iterator it = (*itmol).second.natoms.begin();
+			std::list<i32s>::iterator end = (*itmol).second.natoms.end();
+			for(; it != end; ++it)
+			{
+				molgroups.front().natoms.push_back(*it);
+			}
+		}
+	}
+
+	printf("molgroups size = %lu\n", molgroups.size());
+	for ( std::list<molgroup>::iterator it_mlgr = molgroups.begin();
+		it_mlgr != molgroups.end(); ++it_mlgr)
+	{
+		printf("%s natoms size = %d\n", (GAS == (*it_mlgr).molgrouptype ? "gas" : "membrane or globule"), (*it_mlgr).natoms.size());
+	}
+}
+
+/*##############################################*/
+/*##############################################*/
+
 void model::GetRange(i32s ind, i32s value, iter_al * result)
 {
 	iter_al range[2] = { atom_list.begin(), atom_list.end() };
@@ -3222,7 +3471,7 @@
 	f64 initial_T = 0.;		// initial temperature [K]
 	if (param.maxwell_distribution_init)
 	{
-		dyn->MaxwellDistribution(param.target_T);
+		dyn->MaxwellDistribution(param.target_T, param.inverse_time_init);
 
 		f64 ekin = dyn->KineticEnergy();
 		printf("ekin = %f\n", ekin);
@@ -3236,6 +3485,18 @@
 			printf ("sum_p[%d]\t%e\n", n2,  sum_p[n2]);
 		}
 
+		std::list<struct molgroup> molgroups;
+		this->MakeMoleculesGroups(molgroups);
+		for ( std::list<molgroup>::iterator it_mlgr = molgroups.begin();
+			it_mlgr != molgroups.end(); ++it_mlgr)
+		{
+			it_mlgr->SumMoleculesMomentum(dyn);
+			printf("molgrouptype = %d, atoms number = %d\n", it_mlgr->molgrouptype, it_mlgr->natoms.size());
+			for (i32s n2 = 0; n2 < 3; n2++) {
+				printf ("sum_p[%d]\t%e\n", n2,  it_mlgr->sum_p[n2]);
+			}
+		}
+
 		initial_T = dyn->ConvEKinTemp(ekin);
 		printf("The temperature initiated = %f\n", initial_T);
 	}
@@ -3255,10 +3516,9 @@
 	ofstream logfile;
 	logfile.open(logfilename, ios::out);
 	
-	ofstream ofile;		// the trajectory file...
+	long_ofstream ofile;		// the trajectory file...
 	ofile.open(param.filename, ios::out | ios::binary);
 	
-	const int frame_save_frq = 10000;
 	const int total_frames = param.nsteps_s / frame_save_frq;
 	
 	WriteTrajectoryHeader(ofile, total_frames, dyn, frame_save_frq);
@@ -3280,6 +3540,15 @@
 	
 	for (i32s n1 = 0;n1 < tot_nsteps;n1++)
 	{
+	// check if trajectory output should be made.
+		if (!(n1 % frame_save_frq))
+		{
+			CopyCRD(eng, this, 0);
+			ofile.open(param.filename, ios::out | ios::binary | ios::app);
+			WriteTrajectoryFrame(ofile, dyn);
+			ofile.close();
+		}
+
 		bool checked_terms = true;
 		if (NULL != eng_mm)
 			checked_terms = eng_mm->CheckTerms(eng_pbc);
@@ -3339,22 +3608,25 @@
 		if (n1 >= param.nsteps_h + param.nsteps_e + param.nsteps_s) enable_Pc = false;	// cooling
 
 #if USE_BOUNDARY_OPT_ON_MOLDYN
-		if (!(n1 % 10) || !checked_terms){
-			if (b_opt && param.box_optimization){
+		if (b_opt && (!(n1 % 10) || !checked_terms)){
+			if (box_optimization_always == param.box_optimization) {
 				b_opt->TakeCGStep(conjugate_gradient::Newton2An);
 				if (eng_pbc != NULL)
 				{
 					eng_pbc->log_box_optimization();
 					eng_pbc->set_saved_periodic_box(this);
 				}
-				else
-				{
-					//printf ("box_optimization is disabled eng_pbc = %d\n", eng_pbc);
-				}
 			}
-			else
+			else if (box_optimization_equilibration == param.box_optimization
+				&& n1 < param.nsteps_h + param.nsteps_e)
 			{
-				//printf ("box_optimization is disabled b_opt = %d param.box_optimization = %d\n", b_opt, param.box_optimization);
+				// box_optimization just during heating and equilibration
+				b_opt->TakeCGStep(conjugate_gradient::Newton2An);
+				if (eng_pbc != NULL)
+				{
+					eng_pbc->log_box_optimization();
+					eng_pbc->set_saved_periodic_box(this);
+				}
 			}
 		}
 #endif
@@ -3449,15 +3721,6 @@
 			}
 		}
 		
-	// check if trajectory output should be made.
-		if (!(n1 < param.nsteps_h + param.nsteps_e) && !(n1 % frame_save_frq))
-		{
-			CopyCRD(eng, this, 0);
-			ofile.open(param.filename, ios::out | ios::binary | ios::app);
-			WriteTrajectoryFrame(ofile, dyn);
-			ofile.close();
-		}
-		
 	// check if graphics update should be made.
 		if (!(n1 % 100))
 		{
@@ -4606,7 +4869,7 @@
 			if (!((* it1).flags & ATOMFLAG_IS_HIDDEN)) traj_num_atoms++;
 		}	*/
 		
-		trajfile = new ifstream(fn, ios::in | ios::binary);
+		trajfile = new long_ifstream(fn, ios::in | ios::binary);
 		//trajfile->seekg(8, ios::beg);	// skip the file id...
 		char file_id[10];
 		trajfile->read((char *) & file_id, 8);
@@ -4657,13 +4920,24 @@
 			PrintToLog(str.str().c_str());
 		}
 
-		if (trajectory_version > 11)
+		if (trajectory_version > 11 && trajectory_version <= 15)
 		{
-			float tstep;
-			trajfile->read((char *) & tstep, sizeof(tstep));
+			trajfile->read((char *) & time_step_between_traj_records, sizeof(time_step_between_traj_records));
 			stringstream str;
-			str << _("time step between traj records ") << (tstep / 1000) << _(" * 1.0E-12 s") << endl
-				<< _("the trajectory common time is ") << (tstep * (real_frames - 1) / 1000000) << _(" * 1.0E-9 s") << endl << ends;
+			str << _("time step between traj records ") << (time_step_between_traj_records / 1000) << _(" * 1.0E-12 s") << endl
+				<< _("the trajectory common time is ") << (time_step_between_traj_records * (real_frames - 1) / 1000000) << _(" * 1.0E-9 s") << endl << ends;
+			PrintToLog(str.str().c_str());
+		}
+		else if (trajectory_version > 15)
+		{
+			trajfile->read((char *) & traj_frame_save_frq, sizeof(traj_frame_save_frq));
+			trajfile->read((char *) & traj_tstep1, sizeof(traj_tstep1));
+			time_step_between_traj_records = traj_tstep1 * traj_frame_save_frq;
+			stringstream str;
+			str << _("traj_frame_save_frq ") << traj_frame_save_frq 
+				<< _(" traj_tstep1 ") << traj_tstep1 << endl
+				<< _("time step between traj records ") << (time_step_between_traj_records / 1000) << _(" * 1.0E-12 s") << endl
+				<< _("the trajectory common time is ") << (time_step_between_traj_records * (real_frames - 1) / 1000000) << _(" * 1.0E-9 s") << endl << ends;
 			PrintToLog(str.str().c_str());
 		}
 	}
@@ -4678,11 +4952,10 @@
 	
 	trajfile->seekg(place, ios::beg);
 
-	float tmp;
-
 	if (trajectory_version > 10) {
 
 		float boundary[3];
+		float tmp;
 		trajfile->read((char *) & tmp, sizeof(tmp)); boundary[0] = tmp;
 		trajfile->read((char *) & tmp, sizeof(tmp)); boundary[1] = tmp;
 		trajfile->read((char *) & tmp, sizeof(tmp)); boundary[2] = tmp;
@@ -4699,10 +4972,76 @@
 			saved_boundary_potential_rad_solvent = boundary[2];
 		}
 	}
-	
+
+	if (15 == trajectory_version || 17 == trajectory_version)
+	{
+		for (iter_al it1 = atom_list.begin();it1 != atom_list.end();it1++)
+		{
+		//	if ((* it1).flags & ATOMFLAG_IS_HIDDEN) continue;	// currently all coordinates are written...
+			f64 tmp;
+
+			f64 cdata[3];
+			f64 vdata[3];
+			f64 adata[3];
+			f64 fdata[3];
+			f64 cumsum_vdata[3];
+			f64 cumsum_adata[3];
+			f64 cumsum_fdata[3];
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				cdata[t4] = tmp;
+			}
+
+			(* it1).SetCRD(0, cdata[0], cdata[1], cdata[2]);
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				vdata[t4] = tmp;
+			}
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				adata[t4] = tmp;
+			}
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				fdata[t4] = tmp;
+			}
+
+			if (17 == trajectory_version)
+			{
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & tmp, sizeof(tmp));
+					cumsum_vdata[t4] = tmp;
+				}
+
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & tmp, sizeof(tmp));
+					cumsum_adata[t4] = tmp;
+				}
+
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & tmp, sizeof(tmp));
+					cumsum_fdata[t4] = tmp;
+				}
+			}
+		}
+		return;
+	}
+
 	for (iter_al it1 = atom_list.begin();it1 != atom_list.end();it1++)
 	{
 	//	if ((* it1).flags & ATOMFLAG_IS_HIDDEN) continue;	// currently all coordinates are written...
+		float tmp;
 		
 		fGL cdata[3];
 		for (i32s t4 = 0; t4 < 3; t4++)
@@ -4743,6 +5082,31 @@
 				fdata[t4] = tmp;
 			}
 		}
+
+		if (16 == trajectory_version)
+		{
+			fGL cumsum_vdata[3];
+			fGL cumsum_adata[3];
+			fGL cumsum_fdata[3];
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				cumsum_vdata[t4] = tmp;
+			}
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				cumsum_adata[t4] = tmp;
+			}
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				cumsum_fdata[t4] = tmp;
+			}
+		}
 	}
 }
 
@@ -4765,10 +5129,19 @@
 		return (8 + 2 * sizeof(int));
 	}
 
+	if (trajectory_version <= 15)
+	{
+		// file_id
+		// number_of_atoms,  total_frames
+		// time_step_between_traj_records
+		return (8 + 2 * sizeof(int) + sizeof(float));
+	}
+
 	// file_id
 	// number_of_atoms,  total_frames
-	// tstep
-	return (8 + 2 * sizeof(int) + sizeof(float));
+	// frame_save_frq, tstep
+	return (8 + 3 * sizeof(int) + sizeof(double));
+
 }
 
 size_t model::GetTrajectoryEnergySize()
@@ -4803,10 +5176,31 @@
 
 	if (trajectory_version == 14) {
 		return (GetTrajectoryEnergySize()
-			+ 3 * sizeof(float) // boundary
+			+ 3  * sizeof(float) // boundary
 			+ 12 * traj_num_atoms * sizeof(float)); //crd + force + vel + acc
 	}
 
+	if (trajectory_version == 15) {
+		return (GetTrajectoryEnergySize()
+			+ 3  * sizeof(float) // boundary
+			+ 12 * traj_num_atoms * sizeof(f64)); //crd + force + vel + acc
+	}
+
+
+	if (trajectory_version == 16) {
+		return (GetTrajectoryEnergySize()
+			+ 3  * sizeof(float) // boundary
+			+ 12 * traj_num_atoms * sizeof(float) //crd + force + vel + acc
+			+ 9  * traj_num_atoms * sizeof(float)); //cumsum_force + cumsum_vel + cumsum_acc
+	}
+
+	if (trajectory_version == 17) {
+		return (GetTrajectoryEnergySize()
+			+ 3  * sizeof(float) // boundary
+			+ 12 * traj_num_atoms * sizeof(f64) //crd + force + vel + acc
+			+ 9  * traj_num_atoms * sizeof(f64)); //cumsum_force + cumsum_vel + cumsum_acc
+	}
+
 	return -1;
 }
 
@@ -4815,7 +5209,7 @@
 	return total_traj_frames;
 }
 
-ifstream * model::GetTrajectoryFile(void)
+long_ifstream * model::GetTrajectoryFile(void)
 {
 	return trajfile;
 }
@@ -4830,32 +5224,48 @@
 	current_traj_frame = p1;
 }
 
-void model::WriteTrajectoryHeader(ofstream & ofile, int total_frames, moldyn * dyn, int frame_save_freq)
+void model::SetTrajectoryVersionBeforeMoldyn(i32s version)
+{
+	trajectory_version = version;
+}
+
+void model::SetTrajectoryFrameSaveFrq(int frq)
+{
+	frame_save_frq = frq;
+}
+
+void model::WriteTrajectoryHeader(long_ofstream & ofile, int total_frames, moldyn * dyn, int frame_save_freq)
 {
 	char file_id[10];
 	snprintf(file_id, 9, "traj_v%02d", trajectory_version);
 	cout << "file_id = \"" << file_id << "\"" << endl;
 
 	const int number_of_atoms = GetAtomCount();
-	
+
 	ofile.write((char *) file_id, 8);					// file id, 8 chars.
 	ofile.write((char *) & number_of_atoms, sizeof(number_of_atoms));	// number of atoms, int.
 	ofile.write((char *) & total_frames, sizeof(total_frames));		// total number of frames, int.
 
-	if (trajectory_version > 11)
+	if (trajectory_version > 11 && trajectory_version <= 15)
 	{
-		float tstep = dyn->tstep1 * frame_save_freq;
-		ofile.write((char *) & tstep, sizeof(tstep));
+		float _time_step_between_traj_records = dyn->tstep1 * frame_save_freq;
+		ofile.write((char *) & _time_step_between_traj_records, sizeof(_time_step_between_traj_records));
+	}
+	else if (trajectory_version > 15)
+	{
+		double tstep1 = dyn->tstep1;
+		ofile.write((char *) & frame_save_freq, sizeof(frame_save_freq));
+		ofile.write((char *) & tstep1, sizeof(tstep1));
 	}
 }
 
-void model::WriteTrajectoryFrame(ofstream & ofile, moldyn * dyn)
+void model::WriteTrajectoryFrame(long_ofstream & ofile, moldyn * dyn)
 {
 	const float ekin = dyn->GetEKin();
 	const float epot = dyn->GetEPot();
-	
+
 	float boundary[3] = { -1.0, -1.0, -1.0 };
-	
+
 	engine_bp * eng_bp = dynamic_cast<engine_bp *>(dyn->eng);
 	if (eng_bp != NULL)
 	{
@@ -4863,13 +5273,13 @@
 		boundary[1] = eng_bp->bp_rad_solute;
 		boundary[2] = eng_bp->bp_rad_solvent;
 	}
-	
+
 	engine_pbc * eng_pbc = dynamic_cast<engine_pbc *>(dyn->eng);
 	if (eng_pbc != NULL)
 	{
 		eng_pbc->setTrajBoundary(boundary);
 	}
-	
+
 	ofile.write((char *) & ekin, sizeof(ekin));	// kinetic energy, float.
 	ofile.write((char *) & epot, sizeof(epot));	// potential energy, float.
 
diff -Nur ./libghemical-3.0.0.original/src/model.h ./libghemical-3.0.0/src/model.h
--- ./libghemical-3.0.0.original/src/model.h	2023-02-11 20:23:48.869682815 +0000
+++ ./libghemical-3.0.0/src/model.h	2023-02-12 20:38:58.015870929 +0000
@@ -57,7 +57,7 @@
 
 #include <list>
 #include <vector>
-#include <fstream>
+#include "long_stream.h"
 #include <iostream>
 #include <algorithm>
 using namespace std;
@@ -104,11 +104,16 @@
 	i32s nmol;
 	vector<chn_info> * ref_civ;	// vector<chn_info *> ?!?!?!
 	
-	ifstream * trajfile;		// trajectory files...
+	long_ifstream * trajfile;	// trajectory files...
 	i32s traj_num_atoms;		// trajectory files...
 	i32s total_traj_frames;		// trajectory files...
 	i32s current_traj_frame;	// trajectory files...
 
+	float time_step_between_traj_records; // read from the trajectory
+	int frame_save_frq;                   // used for MolDyn
+	double traj_tstep1;                   // read from the trajectory. timestep [fs]
+	int traj_frame_save_frq;              // read from the trajectory. Used for TrajView_MoleculeCoordinatePlot
+
 	i32s trajectory_version;
 	
 	public:
@@ -320,6 +325,8 @@
 	iter_al FindAtomByIndex(i32s);
 	iter_CDl FindAtomConstraint(atom &);
 	
+	void MakeMoleculesGroups(std::list<struct molgroup>& molgroups);
+	
 	void GetRange(i32s, i32s, iter_al *);	///< This is just a default version of GetRange() using the full range of atom list iterators...
 	
 /// GetRange is used to get a range of atoms that form molecules, residues etc...
@@ -431,13 +438,15 @@
 	size_t GetTrajectoryFrameSize();
 
 	i32s GetTotalFrames(void);
-	ifstream * GetTrajectoryFile(void);
+	long_ifstream * GetTrajectoryFile(void);
 	
 	i32s GetCurrentFrame(void);
 	void SetCurrentFrame(i32s);
-	
-	void WriteTrajectoryHeader(ofstream &, int, moldyn *, int);
-	void WriteTrajectoryFrame(ofstream &, moldyn *);
+
+	void SetTrajectoryVersionBeforeMoldyn(i32s version);
+	void SetTrajectoryFrameSaveFrq(int frq);
+	void WriteTrajectoryHeader(long_ofstream &, int, moldyn *, int);
+	void WriteTrajectoryFrame(long_ofstream &, moldyn *);
 	
 	void EvaluateBFact(void);
 	void EvaluateDiffConst(double);
diff -Nur ./libghemical-3.0.0.original/src/moldyn.cpp ./libghemical-3.0.0/src/moldyn.cpp
--- ./libghemical-3.0.0.original/src/moldyn.cpp	2023-02-11 12:52:01.938245352 +0000
+++ ./libghemical-3.0.0/src/moldyn.cpp	2023-02-12 09:19:34.064716884 +0000
@@ -41,7 +41,11 @@
 	
 	vel = new f64[eng->GetAtomCount() * 3];			// [1.0e+3 m/s]
 	acc = new f64[eng->GetAtomCount() * 3];			// [1.0e+12 m/s^2]
-	
+
+	cumsum_vel = new f64[eng->GetAtomCount() * 3];			// [1.0e+3 m/s]
+	cumsum_acc = new f64[eng->GetAtomCount() * 3];			// [1.0e+12 m/s^2]
+	cumsum_f   = new f64[eng->GetAtomCount() * 3];			// [1.0e+3 m/s]
+
 	mass = new f64[eng->GetAtomCount()];			// [kg/mol]
 	
 	locked = new char[eng->GetAtomCount()];
@@ -73,6 +77,10 @@
 		{
 			vel[counter * 3 + n1] = 0.0;
 			acc[counter * 3 + n1] = 0.0;
+
+			cumsum_vel[counter * 3 + n1] = 0.0;
+			cumsum_acc[counter * 3 + n1] = 0.0;
+			cumsum_f  [counter * 3 + n1] = 0.0;
 		}
 		
 		counter++;
@@ -95,12 +103,16 @@
 	delete[] vel;
 	delete[] acc;
 	
+	delete[] cumsum_vel;
+	delete[] cumsum_acc;
+	delete[] cumsum_f;
+
 	delete[] mass;
 	
 	delete[] locked;
 }
 
-void moldyn::MaxwellDistribution(f64 Temp)
+void moldyn::MaxwellDistribution(f64 Temp, bool inverse_time)
 {
 	for (i32s n1 = 0;n1 < eng->GetAtomCount();n1++)
 	{
@@ -110,7 +122,7 @@
 		{
 			i32u rnum = rand();
 			f64 r1 = ((f64) rnum / (f64) RAND_MAX);
-			vel[n1 * 3 + n2] = invnormaldistribution(r1) * sqrt(1.0*8.314*Temp/mass[n1]) / 1000.;
+			vel[n1 * 3 + n2] = (inverse_time ? -1 : 1 ) * invnormaldistribution(r1) * sqrt(1.0*8.314*Temp/mass[n1]) / 1000.;
 		}
 	}
 }
@@ -122,7 +134,7 @@
 		for (i32s n2 = 0;n2 < 3;n2++)
 		{
 			f64 tmpA = acc[n1 * 3 + n2];
-			
+
 			f64 tmp1 = tstep1 * vel[n1 * 3 + n2] * 1.0e-3;
 			f64 tmp2 = tstep2 * tmpA * 0.5e-9;
 			
@@ -150,13 +162,18 @@
 		}
 		else
 		{
-			acc[n1 * 3 + 0] = -eng->d1[n1 * 3 + 0] / mass[n1];
-			acc[n1 * 3 + 1] = -eng->d1[n1 * 3 + 1] / mass[n1];
-			acc[n1 * 3 + 2] = -eng->d1[n1 * 3 + 2] / mass[n1];
-			
-			vel[n1 * 3 + 0] += tstep1 * acc[n1 * 3 + 0] * 0.5e-6;
-			vel[n1 * 3 + 1] += tstep1 * acc[n1 * 3 + 1] * 0.5e-6;
-			vel[n1 * 3 + 2] += tstep1 * acc[n1 * 3 + 2] * 0.5e-6;
+			for (i32s n2 = 0;n2 < 3;n2++)
+			{
+				acc[n1 * 3 + n2] = -eng->d1[n1 * 3 + n2] / mass[n1];
+				vel[n1 * 3 + n2] += tstep1 * acc[n1 * 3 + n2] * 0.5e-6;
+
+				cumsum_vel[n1 * 3 + n2] += vel[n1 * 3 + n2];
+				cumsum_acc[n1 * 3 + n2] += acc[n1 * 3 + n2];
+			}
+		}
+		for (i32s n2 = 0;n2 < 3;n2++)
+		{
+			cumsum_f[n1 * 3 + n2] += eng->d1[n1 * 3 + n2];
 		}
 	}
 	
@@ -385,7 +402,7 @@
 	for (i32s n2 = 0;n2 < 3;n2++) sum_p[n2] = 0.0;
 }
 
-void molgroup::ForceMoleculesMomentumToZero(moldyn * mld)
+void molgroup::SumMoleculesMomentum(moldyn * mld)
 {
 	for (i32s n2 = 0;n2 < 3;n2++) sum_p[n2] = 0.0;
 	num_locked = 0;
@@ -405,93 +422,45 @@
 			sum_p[n2] += mld->mass[n1] * mld->vel[n1 * 3 + n2];
 		}
 	}
+}
+
+void molgroup::ForceMoleculesMomentumToZero(moldyn * mld)
+{
+	SumMoleculesMomentum(mld);
 
 	f64 dp[3];
-	for (i32s n2 = 0;n2 < 3;n2++)
-		dp[n2] = (/*sum_p1[n2]*/ - sum_p[n2]) / (natoms.size() - num_locked);
 
-	for (std::list<i32s>::iterator it = natoms.begin(); it != natoms.end(); ++it)
+	for (i32s n1 = 0; n1 < natoms.size(); n1++)
 	{
-		i32s n1 = *it;
-
-		if (mld->locked[n1]) continue;
+		for (i32s n2 = 0;n2 < 3;n2++) {
+			dp[n2] = (/*sum_p1[n2]*/ - sum_p[n2]) / (natoms.size() - num_locked);
+		}
 
-		for (i32s n2 = 0; n2 < 3; n2++)
+		for (std::list<i32s>::iterator it = natoms.begin(); it != natoms.end(); ++it)
 		{
-			mld->vel[n1 * 3 + n2] += dp[n2] / mld->mass[n1];
-		}
-	}
+			i32s n1 = *it;
 
-	for (i32s n2 = 0;n2 < 3;n2++) sum_p[n2] = 0.0;
+			if (mld->locked[n1]) continue;
 
-	for (std::list<i32s>::iterator it = natoms.begin(); it != natoms.end(); ++it)
-	{
-		i32s n1 = *it;
+			for (i32s n2 = 0; n2 < 3; n2++)
+			{
+				mld->vel[n1 * 3 + n2] += dp[n2] / mld->mass[n1];
+			}
+		}
 
-		if (mld->locked[n1]) continue;
+		SumMoleculesMomentum(mld);
 
-		for (i32s n2 = 0;n2 < 3;n2++)
-		{
-			sum_p[n2] += mld->mass[n1] * mld->vel[n1 * 3 + n2];
+		for (i32s n2 = 0; n2 < 3; n2++) {
+			printf ("%d sum_p[%d] %0.48e\n", n1, n2, sum_p[n2]);
 		}
 	}
-
-	for (i32s n2 = 0; n2 < 3; n2++)
-		printf ("sum_p[%d] %e\n", n2,  sum_p[n2]);
 }
 
 void moldyn::ForceMoleculesMomentumToZero()
 {
 	model * mdl = eng->GetSetup()->GetModel();
-
-	iter_al it1;
-	iter_al range1[2];
-	iter_al range2[2];
-	i32s n1, nmol;
-	bool iscarbon;
-
-
-
-	std::map<i32s, molecule> molecules;
-	std::map<i32s, molecule>::iterator itmol;
-	for (n1 = 0, it1 = mdl->GetAtomsBegin();
-		 n1 < eng->GetAtomCount() && it1 != mdl->GetAtomsEnd();
-		 n1++, it1++)
-	{
-		nmol = (* it1).id[0];
-		iscarbon = 6 == (* it1).el.GetAtomicNumber();
-		itmol = molecules.find(nmol);
-		if (itmol == molecules.end())
-		{
-			molecules.insert(std::pair<i32s, molecule>((* it1).id[0], molecule(iscarbon ? 1 : 0, n1)));
-		}
-		else
-		{
-			(* itmol).second.ncarbons += iscarbon ? 1 : 0;
-			(* itmol).second.natoms.push_back(n1);
-		}
-	}
-
-
 	std::list<struct molgroup> molgroups;
-	molgroups.push_back(molgroup(GAS));
-	for (itmol = molecules.begin(); itmol != molecules.end(); itmol++)
-	{
-		if ((*itmol).second.ncarbons > 2)
-		{
-			molgroups.push_back(molgroup(MEMBRANE_OR_GLOBULE, (*itmol).second.natoms));
-		}
-		else
-		{
-			std::list<i32s>::iterator it = (*itmol).second.natoms.begin();
-			std::list<i32s>::iterator end = (*itmol).second.natoms.end();
-			for(; it != end; ++it)
-			{
-				molgroups.front().natoms.push_back(*it);
-			}
-		}
-	}
-
+	mdl->MakeMoleculesGroups(molgroups);
 	for ( std::list<molgroup>::iterator it_mlgr = molgroups.begin();
 		it_mlgr != molgroups.end(); ++it_mlgr)
 	{
@@ -499,8 +468,6 @@
 	}
 }
 
-
-
 void moldyn::SumModelMomentum(f64 * sum_p)
 {
 	for (i32s n2 = 0;n2 < 3;n2++) sum_p[n2] = 0.0;
@@ -514,43 +481,119 @@
 	}
 }
 
-void moldyn::SaveTrajectoryFrame(ofstream& ofile, i32s trajectory_version)
+void moldyn::SaveTrajectoryFrame(long_ofstream& ofile, i32s trajectory_version)
 {
-	float t1a;
-	const int number_of_atoms = eng->GetAtomCount();
-	for (i32s tt1 = 0;tt1 < number_of_atoms;tt1++)
+	if (trajectory_version < 15 || 16 == trajectory_version)
 	{
-		for (i32s tt2 = 0;tt2 < 3;tt2++)
+		float t1a;
+		const int number_of_atoms = eng->GetAtomCount();
+		for (i32s tt1 = 0;tt1 < number_of_atoms;tt1++)
 		{
-			t1a = eng->crd[tt1 * 3 + tt2];
-			ofile.write((char *) & t1a, sizeof(t1a));
-		}
+			for (i32s tt2 = 0;tt2 < 3;tt2++)
+			{
+				t1a = eng->crd[tt1 * 3 + tt2];
+				ofile.write((char *) & t1a, sizeof(t1a));
+			}
+
+			if (trajectory_version > 12)
+			{
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = vel[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+			}
 
-		if (trajectory_version > 12)
+			if (trajectory_version > 13)
+			{
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = acc[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+			}
+
+			if (trajectory_version > 11)
+			{
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = eng->d1[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+			}
+
+			if (16 == trajectory_version)
+			{
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_vel[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_acc[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_f[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+			}
+		}
+	}
+	else if (15 == trajectory_version || 17 == trajectory_version)
+	{
+		f64 t1a;
+		const int number_of_atoms = eng->GetAtomCount();
+		for (i32s tt1 = 0;tt1 < number_of_atoms;tt1++)
 		{
 			for (i32s tt2 = 0;tt2 < 3;tt2++)
 			{
+				t1a = eng->crd[tt1 * 3 + tt2];
+				ofile.write((char *) & t1a, sizeof(t1a));
+			}
+
+			for (i32s tt2 = 0;tt2 < 3;tt2++)
+			{
 				t1a = vel[tt1 * 3 + tt2];
 				ofile.write((char *) & t1a, sizeof(t1a));
 			}
-		}
 
-		if (trajectory_version > 13)
-		{
 			for (i32s tt2 = 0;tt2 < 3;tt2++)
 			{
 				t1a = acc[tt1 * 3 + tt2];
 				ofile.write((char *) & t1a, sizeof(t1a));
 			}
-		}
 
-		if (trajectory_version > 11)
-		{
 			for (i32s tt2 = 0;tt2 < 3;tt2++)
 			{
 				t1a = eng->d1[tt1 * 3 + tt2];
 				ofile.write((char *) & t1a, sizeof(t1a));
 			}
+
+			if (17 == trajectory_version)
+			{
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_vel[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_acc[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_f[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+			}
 		}
 	}
 }
diff -Nur ./libghemical-3.0.0.original/src/moldyn.h ./libghemical-3.0.0/src/moldyn.h
--- ./libghemical-3.0.0.original/src/moldyn.h	2023-02-20 02:59:56.066845433 +0000
+++ ./libghemical-3.0.0/src/moldyn.h	2023-02-20 17:44:14.381744339 +0000
@@ -34,6 +34,13 @@
 
 /*################################################################################################*/
 
+enum box_optimization_moldyn_mode
+{
+	box_optimization_no = 0,
+	box_optimization_always,
+	box_optimization_equilibration, // box_optimization just during heating and equilibration
+};
+
 class moldyn_param
 {
 	protected:
@@ -61,10 +68,12 @@
 	bool constant_P;
 
 	bool maxwell_distribution_init;
+	bool inverse_time_init;
 	
 	char filename[256];
 
-	bool recalc_box, box_optimization;
+	bool recalc_box;
+	box_optimization_moldyn_mode box_optimization;
 	
 	public:
 	
@@ -96,9 +105,10 @@
 		constant_P = false;
 
 		maxwell_distribution_init = true;
+		inverse_time_init = false;
 
 		recalc_box = false;
-		box_optimization = true;
+		box_optimization = box_optimization_always;
 		
 		std::strcpy(filename, "untitled.traj");
 	}
@@ -139,6 +149,7 @@
 
 	molgroup(enum molgrouptype _molgrouptype, std::list<i32s> _natoms);
 
+	void SumMoleculesMomentum(moldyn * mld);
 	void ForceMoleculesMomentumToZero(moldyn * mld);
 };
 
@@ -163,7 +174,11 @@
 	
 	f64 * vel;			// [1.0e+3 m/s]
 	f64 * acc;			// [1.0e+12 m/s^2]
-	
+
+	f64 * cumsum_vel;
+	f64 * cumsum_acc;
+	f64 * cumsum_f;
+
 	f64 * mass;			// [kg/mol]
 	
 	char * locked;
@@ -179,9 +194,10 @@
 	
 	f64 sum_of_masses;	// this is for density...
 	
-	friend void model::WriteTrajectoryFrame(ofstream &, moldyn *);
-	friend void model::WriteTrajectoryHeader(ofstream & ofile, int, moldyn *, int);
+	friend void model::WriteTrajectoryFrame(long_ofstream &, moldyn *);
+	friend void model::WriteTrajectoryHeader(long_ofstream & ofile, int, moldyn *, int);
 	friend void molgroup::ForceMoleculesMomentumToZero(moldyn * );
+	friend void molgroup::SumMoleculesMomentum(moldyn * );
 	
 	public:
 	
@@ -200,7 +216,7 @@
 	moldyn(engine *, f64);
 	virtual ~moldyn(void);
 
-	void MaxwellDistribution(f64 Temp);
+	void MaxwellDistribution(f64 Temp, bool inverse_time);
 	
 	f64 GetEKin(void) { return ekin; }
 	f64 GetEPot(void) { return epot; }
@@ -217,7 +233,7 @@
 	void ForceModelMomentumToZero();
 	void ForceMoleculesMomentumToZero();
 
-	void SaveTrajectoryFrame(ofstream& ofile, i32s trajectory_version);
+	void SaveTrajectoryFrame(long_ofstream& ofile, i32s trajectory_version);
 };
 
 /*################################################################################################*/
diff -Nur ./ghemical-3.0.0.original/src/gtk_moldyn_dialog.cpp ./ghemical-3.0.0/src/gtk_moldyn_dialog.cpp
--- ./ghemical-3.0.0.original/src/gtk_moldyn_dialog.cpp	2023-02-11 12:52:01.926245353 +0000
+++ ./ghemical-3.0.0/src/gtk_moldyn_dialog.cpp	2023-02-20 19:31:56.117610241 +0000
@@ -21,6 +21,7 @@
 #include "gtk_moldyn_dialog.h"
 
 #include "local_i18n.h"
+#include "ghemical/moldyn.h"
 
 #include <gtk/gtk.h>
 
@@ -65,7 +66,9 @@
 
 	checkbutton_maxwell_distribution_init = glade_xml_get_widget(xml, "checkbutton_maxwell_distribution_init");
 	checkbutton_recalc_box = glade_xml_get_widget(xml, "checkbutton_recalc_box");
-	checkbutton_box_optimization = glade_xml_get_widget(xml, "checkbutton_box_optimization");
+	radiobutton_box_optimization_0 = glade_xml_get_widget(xml, "radiobutton_box_optimization_0");
+	radiobutton_box_optimization_1 = glade_xml_get_widget(xml, "radiobutton_box_optimization_1");
+	radiobutton_box_optimization_2 = glade_xml_get_widget(xml, "radiobutton_box_optimization_2");
 
 	entry_trajfile = glade_xml_get_widget(xml, "entry_trajfile");
 	button_browse = glade_xml_get_widget(xml, "button_browse");
@@ -132,7 +135,27 @@
 
 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(checkbutton_maxwell_distribution_init), (param->maxwell_distribution_init ? TRUE : FALSE));
 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(checkbutton_recalc_box), (param->recalc_box ? TRUE : FALSE));
-	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(checkbutton_box_optimization), (param->box_optimization ? TRUE : FALSE));
+	switch (param->box_optimization)
+	{
+	case box_optimization_no:
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radiobutton_box_optimization_0), TRUE);
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radiobutton_box_optimization_1), FALSE);
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radiobutton_box_optimization_2), FALSE);
+		break;
+	case box_optimization_always:
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radiobutton_box_optimization_0), FALSE);
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radiobutton_box_optimization_1), TRUE);
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radiobutton_box_optimization_2), FALSE);
+		break;
+	case box_optimization_equilibration:
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radiobutton_box_optimization_0), FALSE);
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radiobutton_box_optimization_1), FALSE);
+		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(radiobutton_box_optimization_2), TRUE);
+		break;
+	
+	default:
+		break;
+	}
 
 	gtk_entry_set_text(GTK_ENTRY(entry_trajfile), param->filename);
 	
@@ -219,7 +242,19 @@
 
 	ref->param->maxwell_distribution_init = (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ref->checkbutton_maxwell_distribution_init)) == TRUE ? true : false);
 	ref->param->recalc_box = (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ref->checkbutton_recalc_box)) == TRUE ? true : false);
-	ref->param->box_optimization = (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ref->checkbutton_box_optimization)) == TRUE ? true : false);
+
+	if (TRUE == gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ref->radiobutton_box_optimization_0)))
+	{
+		ref->param->box_optimization = box_optimization_no;
+	}
+	if (TRUE == gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ref->radiobutton_box_optimization_1)))
+	{
+		ref->param->box_optimization = box_optimization_always;
+	}
+	if (TRUE == gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ref->radiobutton_box_optimization_2)))
+	{
+		ref->param->box_optimization = box_optimization_equilibration;
+	}
 
 
 	buffer = gtk_entry_get_text(GTK_ENTRY(ref->entry_trajfile));
diff -Nur ./ghemical-3.0.0.original/src/gtk_moldyn_dialog.h ./ghemical-3.0.0/src/gtk_moldyn_dialog.h
--- ./ghemical-3.0.0.original/src/gtk_moldyn_dialog.h	2023-02-11 12:52:01.930245352 +0000
+++ ./ghemical-3.0.0/src/gtk_moldyn_dialog.h	2023-02-20 19:21:15.829623529 +0000
@@ -57,7 +57,9 @@
 
 	GtkWidget * checkbutton_maxwell_distribution_init;
 	GtkWidget * checkbutton_recalc_box;
-	GtkWidget * checkbutton_box_optimization;
+	GtkWidget * radiobutton_box_optimization_0;
+	GtkWidget * radiobutton_box_optimization_1;
+	GtkWidget * radiobutton_box_optimization_2;
 
 	
 	GtkWidget * entry_trajfile;
diff -Nur ./ghemical-3.0.0.original/src/project.cpp ./ghemical-3.0.0/src/project.cpp
--- ./ghemical-3.0.0.original/src/project.cpp	2023-02-11 12:52:01.930245352 +0000
+++ ./ghemical-3.0.0/src/project.cpp	2023-05-26 08:41:59.114846251 +0000
@@ -61,6 +61,8 @@
 
 #include "local_i18n.h"
 
+#include "float.h"
+
 #include <cstring>
 #include <fstream>
 #include <sstream>
@@ -68,6 +70,8 @@
 #include <algorithm>
 using namespace std;
 
+
+
 /*################################################################################################*/
 
 custom_transformer_client::custom_transformer_client(void) :
@@ -1639,6 +1643,25 @@
 		return;
 	}
 	
+
+	if (!strcmp("make_plot_mol_crd", kw1))
+	{
+		char kw2[32]; istr >> kw2;	// A
+		char kw3[32]; istr >> kw3;	// B
+		char kw4[32]; istr >> kw4;	// B
+		char kw5[32]; istr >> kw5;	// B
+
+		char ** endptr = NULL;
+
+		i32s molgrouptype = strtol(kw2, endptr, 10);
+		i32s ind_mol      = strtol(kw3, endptr, 10);
+		i32s dim          = strtol(kw4, endptr, 10);
+		i32s crd_type     = strtol(kw5, endptr, 10);
+
+		TrajView_MoleculeCoordinatePlot((enum molgrouptype)molgrouptype, ind_mol, dim, crd_type);
+		return;
+	}
+
 	if (!strcmp("sel_atoms_with_flag", kw1))
 	{
 		char kw2[32]; istr >> kw2;	
@@ -3695,6 +3718,644 @@
 	Message(str.str().c_str());
 }
 
+void project::TrajView_MoleculeCoordinatePlot(enum molgrouptype molgrouptype, i32s ind_mol, i32s dim, i32s crd_type)
+{
+	if (!this->GetTrajectoryFile())
+	{
+		this->ErrorMessage(_("Trajectory file does not opened?"));
+		return;
+	}
+
+	const char * crd_name [] = {"coordinate", "velocity", "acceleration", "force"};
+
+	const char * s1 = "frame(num)"; const char * sv = "distance (nm)";
+	p1dview_wcl * plot = AddPlot1DClient(s1, sv, true);
+	std::string title = std::string("Molecule Coordinate plot of ") + traj_filename;
+	plot->SetTitle(title.c_str());
+
+	float ekin;
+	float epot;
+
+	i32s shift = 0;
+	f64 first_coordinate = 0.0;
+	f64 previouse_coordinate = 0.0;
+	f64 sum_d_coordinate_error = 0.0;
+	f64 sum_coordinate = 0.0;
+	f64 sum_velocity = 0.0;
+	f64 previouse_velocity = 0.0;
+	f64 sum_d_velocity_error = 0.0;
+	f64 previouse_acceleration = 0.0;
+	f64 sum_acceleration = 0.0;
+	f64 sum_force = 0.0;
+
+	std::list<struct molgroup> molgroups;
+	this->MakeMoleculesGroups(molgroups);
+
+	size_t natoms = atom_list.size();
+	std::vector<f64> c_data; c_data.resize(natoms * 3);
+	std::vector<f64> previouse_c_data; previouse_c_data.resize(natoms * 3, 0.0);
+	std::vector<f64> v_data; v_data.resize(natoms * 3);
+	std::vector<f64> previouse_v_data; previouse_v_data.resize(natoms * 3, 0.0);
+	std::vector<f64> a_data; a_data.resize(natoms * 3);
+	std::vector<f64> f_data; f_data.resize(natoms * 3);
+
+	std::vector<f64> cumsum_v_data; cumsum_v_data.resize(natoms * 3);
+	std::vector<f64> cumsum_a_data; cumsum_a_data.resize(natoms * 3);
+	std::vector<f64> cumsum_f_data; cumsum_f_data.resize(natoms * 3);
+
+	int64_t gas_atom_went_down_out_from_membrane = 0,
+			gas_atom_went_up_into_memrane = 0,
+			gas_atom_went_down_into_membrane = 0,
+			gas_atom_went_up_out_from_memrane = 0;
+
+	i32s max_frames = this->GetTotalFrames();
+	for (i32s loop = 0; loop < max_frames; loop++)
+	{
+		this->SetCurrentFrame(loop);
+
+		size_t place = GetTrajectoryHeaderSize();						// skip the header...
+		place += GetTrajectoryFrameSize() * current_traj_frame;		// get the correct frame...
+		//place += GetTrajectoryEnergySize();							// skip epot and ekin...
+
+		trajfile->seekg(place, ios::beg);
+
+		trajfile->read((char *) & ekin, sizeof(ekin));
+		trajfile->read((char *) & epot, sizeof(epot));
+
+		float boundary[3];
+		if (trajectory_version > 10)
+		{
+			float tmp;
+			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[0] = tmp;
+			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[1] = tmp;
+			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[2] = tmp;
+			if (loop  ==  max_frames - 1) {
+				printf("boundary %f %f %f\n", boundary[0], boundary[1], boundary[2]);
+			}
+		}
+
+		i32s ind = 0;
+		mt_a1 = mt_a2 = mt_a3 = NULL;
+
+		for (iter_al it1 = atom_list.begin(); it1 != atom_list.end(); it1++)
+		{
+			f64 cdata[3];
+			f64 vdata[3];
+			f64 adata[3];
+			f64 fdata[3];
+
+			if (trajectory_version < 15 || 16 == trajectory_version)
+			{
+				float t1a;
+				for (i32s t4 = 0;t4 < 3;t4++)
+				{
+					trajfile->read((char *) & t1a, sizeof(t1a));
+					cdata[t4] = t1a;
+					c_data[3 * ind + t4] = t1a;
+				}
+
+				if (trajectory_version > 12)
+				{
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						vdata[t4] = t1a;
+						v_data[3 * ind + t4] = t1a;
+					}
+				}
+
+				if (trajectory_version > 13)
+				{
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						adata[t4] = t1a;
+						a_data[3 * ind + t4] = t1a;
+					}
+				}
+
+				if (trajectory_version > 11)
+				{
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						fdata[t4] = t1a;
+						f_data[3 * ind + t4] = t1a;
+					}
+				}
+
+				if (16 == trajectory_version)
+				{
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						vdata[t4] = t1a;
+						cumsum_v_data[3 * ind + t4] = t1a;
+					}
+
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						adata[t4] = t1a;
+						cumsum_a_data[3 * ind + t4] = t1a;
+					}
+
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						fdata[t4] = t1a;
+						cumsum_f_data[3 * ind + t4] = t1a;
+					}
+				}
+			}
+			else if (15 == trajectory_version || 17 == trajectory_version)
+			{
+				f64 t1a;
+				for (i32s t4 = 0;t4 < 3;t4++)
+				{
+					trajfile->read((char *) & t1a, sizeof(t1a));
+					cdata[t4] = t1a;
+					c_data[3 * ind + t4] = t1a;
+				}
+
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & t1a, sizeof(t1a));
+					vdata[t4] = t1a;
+					v_data[3 * ind + t4] = t1a;
+				}
+
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & t1a, sizeof(t1a));
+					adata[t4] = t1a;
+					a_data[3 * ind + t4] = t1a;
+				}
+
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & t1a, sizeof(t1a));
+					fdata[t4] = t1a;
+					f_data[3 * ind + t4] = t1a;
+				}
+
+				if (17 == trajectory_version)
+				{
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						vdata[t4] = t1a;
+						cumsum_v_data[3 * ind + t4] = t1a;
+					}
+
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						adata[t4] = t1a;
+						cumsum_a_data[3 * ind + t4] = t1a;
+					}
+
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						fdata[t4] = t1a;
+						cumsum_f_data[3 * ind + t4] = t1a;
+					}
+				}
+			}
+
+			//printf("%d -f/a %f %f %f\n", ind
+			//	, -fdata[0]/adata[0]
+			//	, -fdata[1]/adata[1]
+			//	, -fdata[2]/adata[2]
+			//	);
+
+			//printf("%d -f / a %f %f %f %f %f\n", ind
+			//	, -f_data[3 * ind + 0]/a_data[3 * ind + 0]
+			//	, -f_data[3 * ind + 1]/a_data[3 * ind + 1]
+			//	, -f_data[3 * ind + 2]/a_data[3 * ind + 2]
+			//	, -f_data[3 * ind + 2],a_data[3 * ind + 2]
+			//	);
+
+			/*printf("v, a %f %f %f %f %f %f\n"
+				, vdata[0],adata[0]
+				, vdata[1],adata[1]
+				, vdata[2],adata[2]
+				);*/
+
+			/*
+			acc[n1 * 3 + 0] = -eng->d1[n1 * 3 + 0] / mass[n1];
+			acc[n1 * 3 + 1] = -eng->d1[n1 * 3 + 1] / mass[n1];
+			acc[n1 * 3 + 2] = -eng->d1[n1 * 3 + 2] / mass[n1];
+			*/
+
+			ind++;
+		}
+
+		f64 coordinate = 0;
+		f64 velocity = 0;
+		f64 acceleration = 0;
+		f64 force = 0;
+
+		f64 cumsum_velocity = 0;
+		f64 cumsum_acceleration = 0;
+		f64 cumsum_force = 0;
+
+		f64 max_membrane_crd = -FLT_MAX, min_membrane_crd = FLT_MAX;
+		bool is_membrane_cutted_by_boundary = false;
+
+		i32s indmol=0;
+		for (std::list<molgroup>::iterator it_mlgr = molgroups.begin();
+			it_mlgr != molgroups.end(); ++it_mlgr)
+		{
+			if (molgrouptype != it_mlgr->molgrouptype)
+			{
+				continue;
+			}
+
+			if (ind_mol != indmol)
+			{
+				indmol++;
+				continue;
+			}
+
+			f64 crd, vel, acc, frc,
+				cumsum_vel, cumsum_acc, cumsum_frc,
+				max_crd = -FLT_MAX, min_crd = FLT_MAX,
+				sum_crd = 0.0, sum_vel = 0.0, sum_acc = 0.0, sum_frc = 0.0, 
+				sum_cumsum_vel = 0.0, sum_cumsum_acc = 0.0, sum_cumsum_frc = 0.0, 
+				pre_atom_crd = 0.0, pre_loop_vel = 0.0,
+				pre_loop_crd = 0.0;
+
+			bool is_cutted_by_boundary = false;
+
+			for (std::list<i32s>::iterator it = it_mlgr->natoms.begin();
+				it != it_mlgr->natoms.end(); ++it)
+			{
+				ind = *it;
+				crd = c_data[3 * ind + dim];
+				vel = v_data[3 * ind + dim];
+				acc = a_data[3 * ind + dim];
+				frc = f_data[3 * ind + dim];
+				cumsum_vel = cumsum_v_data[3 * ind + dim];
+				cumsum_acc = cumsum_a_data[3 * ind + dim];
+				cumsum_frc = cumsum_f_data[3 * ind + dim];
+				pre_loop_crd = previouse_c_data[3 * ind + dim];
+				pre_loop_vel = previouse_v_data[3 * ind + dim];
+
+			//printf("crd vel acc frc %f %f %f %f\n"
+			//	, crd, vel, acc, frc
+			//	);
+
+			//printf("ind %d dim %d -frc/acc %f %f %f\n", ind, dim
+			//	, -frc/acc
+			//	, -frc, acc
+			//	);
+
+				//if (0 == crd_type)
+				{
+					//this->apply_periodic_cond(eng, test2);
+					if (crd - pre_atom_crd > boundary[dim])
+					{
+						crd -= 2 * boundary[dim];
+						is_cutted_by_boundary = true;
+					}
+					if (crd - pre_atom_crd < -boundary[dim])
+					{
+						crd += 2 * boundary[dim];
+						is_cutted_by_boundary = true;
+					}
+				}
+
+				if (max_crd < crd) {
+					max_crd = crd;
+				}
+
+				if (min_crd > crd) {
+					min_crd = crd;
+				}
+
+				sum_crd += crd;
+				pre_atom_crd = crd;
+
+				sum_vel += vel;
+
+				sum_acc += acc;
+				sum_frc += frc;
+
+				sum_cumsum_vel += cumsum_vel;
+				sum_cumsum_acc += cumsum_acc;
+				sum_cumsum_frc += cumsum_frc;
+			}
+
+			//if (crd_type < 3) // crd, vel and acc, but not force
+			sum_crd /= it_mlgr->natoms.size();
+			sum_vel /= it_mlgr->natoms.size();
+			sum_acc /= it_mlgr->natoms.size();
+
+			sum_cumsum_vel /= it_mlgr->natoms.size();
+			sum_cumsum_acc /= it_mlgr->natoms.size();
+
+			coordinate   = sum_crd;
+			velocity     = sum_vel;
+			acceleration = sum_acc;
+			force        = sum_frc;
+
+			cumsum_velocity     = sum_cumsum_vel;
+			cumsum_acceleration = sum_cumsum_acc;
+			cumsum_force        = sum_cumsum_frc;
+
+			if (MEMBRANE_OR_GLOBULE == it_mlgr->molgrouptype)
+			{
+				max_membrane_crd = max_crd, min_membrane_crd = min_crd;
+				is_membrane_cutted_by_boundary = is_cutted_by_boundary;
+			}
+
+			indmol++;
+		}
+
+
+		for (std::list<molgroup>::iterator it_mlgr = molgroups.begin();
+			it_mlgr != molgroups.end(); ++it_mlgr)
+		{
+			if (GAS != it_mlgr->molgrouptype)
+			{
+				continue;
+			}
+
+			f64 crd, pre_loop_crd = 0.0;;
+
+			for (std::list<i32s>::iterator it = it_mlgr->natoms.begin();
+				it != it_mlgr->natoms.end(); ++it)
+			{
+				ind = *it;
+				crd = c_data[3 * ind + dim];
+				pre_loop_crd = previouse_c_data[3 * ind + dim];
+
+				if (loop > 0)
+				{
+					if (is_membrane_cutted_by_boundary)
+					{
+						if (min_membrane_crd < -boundary[dim])
+						{
+							if (crd <= min_membrane_crd + 2 * boundary[dim] && pre_loop_crd > min_membrane_crd + 2 * boundary[dim])
+							{
+								gas_atom_went_down_out_from_membrane++;
+							}
+							if (crd >= min_membrane_crd + 2 * boundary[dim] && pre_loop_crd < min_membrane_crd + 2 * boundary[dim])
+							{
+								gas_atom_went_up_into_memrane++;
+							}
+
+							if (crd <= max_membrane_crd && pre_loop_crd > max_membrane_crd)
+							{
+								gas_atom_went_down_into_membrane++;
+							}
+							if (crd >= max_membrane_crd && pre_loop_crd < max_membrane_crd)
+							{
+								gas_atom_went_up_out_from_memrane++;
+							}
+						}
+
+						if (max_membrane_crd > boundary[dim])
+						{
+							if (crd <= min_membrane_crd && pre_loop_crd > min_membrane_crd)
+							{
+								gas_atom_went_down_out_from_membrane++;
+							}
+							if (crd >= min_membrane_crd && pre_loop_crd < min_membrane_crd)
+							{
+								gas_atom_went_up_into_memrane++;
+							}
+
+							if (crd <= max_membrane_crd - 2 * boundary[dim]&& pre_loop_crd > max_membrane_crd - 2 * boundary[dim])
+							{
+								gas_atom_went_down_into_membrane++;
+							}
+							if (crd >= max_membrane_crd - 2 * boundary[dim] && pre_loop_crd < max_membrane_crd - 2 * boundary[dim])
+							{
+								gas_atom_went_up_out_from_memrane++;
+							}
+						}
+					}
+					else
+					{
+						if (crd <= min_membrane_crd && pre_loop_crd > min_membrane_crd)
+						{
+							gas_atom_went_down_out_from_membrane++;
+						}
+						if (crd >= min_membrane_crd && pre_loop_crd < min_membrane_crd)
+						{
+							gas_atom_went_up_into_memrane++;
+						}
+
+						if (crd <= max_membrane_crd && pre_loop_crd > max_membrane_crd)
+						{
+							gas_atom_went_down_into_membrane++;
+						}
+						if (crd >= max_membrane_crd && pre_loop_crd < max_membrane_crd)
+						{
+							gas_atom_went_up_out_from_memrane++;
+						}
+					}
+				}
+			}
+
+			//
+		}
+
+		//if (0 == crd_type)
+		{
+			if (coordinate - previouse_coordinate > boundary[dim])
+			{
+				shift -= 1;
+				if (loop  ==  max_frames - 1) printf("coordinate %e - previouse_coordinate %e > boundary[dim] %e shift %d\n", coordinate, previouse_coordinate, boundary[dim], shift);
+			}
+			if (coordinate - previouse_coordinate < -boundary[dim])
+			{
+				shift += 1;
+				if (loop  ==  max_frames - 1) printf("coordinate %e - previouse_coordinate %f < boundary[dim] %e shift %d\n", coordinate, previouse_coordinate, boundary[dim], shift);
+			}
+			sum_coordinate = (coordinate + 2 * shift * boundary[dim]) - first_coordinate;
+		}
+		//else
+		{
+			sum_velocity     += velocity;
+			sum_acceleration += acceleration;
+			sum_force        += force;
+		}
+
+		/*
+		f64 tstep1;		// timestep [fs] // [1.0e-15 s]
+		f64 tstep2;		// timestep ^ 2	 // [1.0e-30 s^2]		
+
+		f64 tmpA = acc[n1 * 3 + n2];
+		f64 tmp1 = tstep1 * vel[n1 * 3 + n2] * 1.0e-3;
+		f64 tmp2 = tstep2 * tmpA * 0.5e-9;
+
+		if (!locked[n1])
+		{
+			eng->crd[n1 * 3 + n2] += tmp1 + tmp2;
+			vel[n1 * 3 + n2] += tstep1 * tmpA * 0.5e-6;
+		}
+
+		vel[n1 * 3 + 0] += tstep1 * acc[n1 * 3 + 0] * 0.5e-6;
+		vel[n1 * 3 + 1] += tstep1 * acc[n1 * 3 + 1] * 0.5e-6;
+		vel[n1 * 3 + 2] += tstep1 * acc[n1 * 3 + 2] * 0.5e-6;
+		*/
+
+		f64 tstep1 = /*0.5*/traj_tstep1, tstep2 = tstep1 * tstep1;
+		f64 dcv    = tstep1 * previouse_velocity * 1.0e-3;
+		f64 dca    = tstep2 * previouse_acceleration * 0.5e-9;
+		f64 dc     = dcv + dca;
+
+		f64 dv1 = tstep1 * previouse_acceleration * 0.5e-6;
+		f64 dv2 = tstep1 * acceleration * 0.5e-6;
+		f64 dv  = dv1 + dv2;
+
+		f64 d_coordinate = coordinate - previouse_coordinate;
+		f64 d_velocity   = velocity   - previouse_velocity;
+
+		f64 d_coordinate_error = d_coordinate - dc;
+		f64 d_velocity_error   = d_velocity   - dv;
+
+		sum_d_coordinate_error += d_coordinate_error;
+		sum_d_velocity_error   += d_velocity_error;
+
+		if (loop  ==  max_frames - 1) {
+			printf("loop %d dc %0.06e = %0.06e (%0.06e + %0.06e) error=%0.06e %0.06e\n", loop
+				, d_coordinate
+				, dc
+				, dcv, dca
+				, d_coordinate_error
+				, d_velocity_error
+				);
+		}
+
+		f64 value = 0.0;
+		switch (crd_type)
+		{
+		case 0:
+			value = coordinate + 2 * shift * boundary[dim];
+			break;
+		case 1:
+			value = velocity;
+			break;
+		case 2:
+			value = acceleration;
+			break;
+		case 3:
+			value = force;
+			break;
+		case 4:
+			value = d_coordinate_error;
+			break;
+		case 5:
+			value = d_velocity_error;
+			break;
+		case 6:
+			value = sum_d_coordinate_error;
+			break;
+		case 7:
+			value = sum_d_velocity_error;
+			break;
+		case 8:
+			value = cumsum_velocity;
+			break;
+		case 9:
+			value = cumsum_acceleration;
+			break;
+		case 10:
+			value = cumsum_force;
+			break;
+		case 11:
+			value = gas_atom_went_down_out_from_membrane - gas_atom_went_up_into_memrane;
+			break;
+		case 12:
+			value = gas_atom_went_down_into_membrane - gas_atom_went_up_out_from_memrane;
+			break;
+
+		case 13:
+			value = gas_atom_went_down_out_from_membrane;
+			break;
+		case 14:
+			value = gas_atom_went_up_into_memrane;
+			break;
+		case 15:
+			value = gas_atom_went_down_into_membrane;
+			break;
+		case 16:
+			value = gas_atom_went_up_out_from_memrane;
+			break;
+
+		default:
+			break;
+		}
+
+		plot->AddData(loop, value);
+
+		mt_a1 = mt_a2 = mt_a3 = NULL;
+
+		previouse_coordinate   = coordinate;
+		previouse_velocity     = velocity;
+		previouse_acceleration = acceleration;
+
+		if (0 == loop)
+		{
+			first_coordinate = coordinate;
+		}
+
+		for (i32s t4 = 0; t4 < natoms * 3; t4++)
+		{
+			previouse_c_data[t4] = c_data[t4];
+			previouse_v_data[t4] = v_data[t4];
+		}
+	}
+
+	f64 mean_coordinate   = sum_coordinate   / max_frames;
+	f64 mean_velocity     = sum_velocity     / max_frames;
+	f64 mean_acceleration = sum_acceleration / max_frames;
+	f64 mean_force        = sum_force        / max_frames;
+
+	f64 mean_coordinate_per_time = mean_coordinate / this->time_step_between_traj_records;
+
+	f64 mean_d_coordinate_error = sum_d_coordinate_error / max_frames;
+	f64 mean_d_velocity_error   = sum_d_velocity_error   / max_frames;
+
+	printf("sum_d_coordinate_error / sum_coordinate %f\n", sum_d_coordinate_error / sum_coordinate);
+	printf("sum_coordinate - sum_d_coordinate_error %f\n", sum_coordinate - sum_d_coordinate_error);
+
+	printf("sum_coordinate  %f (nm)\n",  sum_coordinate);
+	printf("mean_coordinate %e (nm/frame)\n", mean_coordinate);
+
+	printf("sum_d_coordinate_error  %f \n",  sum_d_coordinate_error);
+	printf("mean_d_coordinate_error %e\n", mean_d_coordinate_error);
+
+	printf("sum_velocity  %f\n",  sum_velocity);
+	printf("mean_velocity %e [1.0e+3 m/s]\n", mean_velocity);
+	printf("mean_coordinate_per_time %e [nm/fs]\n", mean_coordinate_per_time);
+
+	printf("sum_d_velocity_error  %f\n",  sum_d_velocity_error);
+	printf("mean_d_velocity_error %e\n", mean_d_velocity_error);
+
+	printf("sum_acceleration  %f\n",  sum_acceleration);
+	printf("mean_acceleration %f\n", mean_acceleration);
+
+	printf("sum_force %f\n",  sum_force);
+	printf("mean_force %f\n", mean_force);
+
+	printf("gas_atom_went_down_out_from_membrane %ld\n", gas_atom_went_down_out_from_membrane);
+	printf("gas_atom_went_up_into_memrane %ld\n", gas_atom_went_up_into_memrane);
+	printf("gas_atom_went_down_into_membrane %ld\n" , gas_atom_went_down_into_membrane);
+	printf("gas_atom_went_up_out_from_memrane %ld\n", gas_atom_went_up_out_from_memrane);
+
+	//printf("sum_%s %f\n",  crd_name[crd_type], sum_coordinate);
+	//printf("mean_%s %f\n", crd_name[crd_type], mean_coordinate);
+
+	plot->Finalize();
+	plot->GetWnd()->RequestUpdate(false);
+}
+
 void project::TrajView_CoordinatePlot(i32s inda, i32s dim)
 {
 	if (!this->GetTrajectoryFile())
@@ -3710,6 +4371,9 @@
 	float epot;
 	float tmp;
 
+	i32s shift = 0;
+	fGL previouse_coordinate = 0.0;
+
 	i32s max_frames = this->GetTotalFrames();
 	for (i32s loop = 0;loop < max_frames;loop++)
 	{
@@ -3724,9 +4388,9 @@
 		trajfile->read((char *) & ekin, sizeof(ekin));
 		trajfile->read((char *) & epot, sizeof(epot));
 
+		float boundary[3];
 		if (trajectory_version > 10)
 		{
-			float boundary[3];
 			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[0] = tmp;
 			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[1] = tmp;
 			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[2] = tmp;
@@ -3806,10 +4470,22 @@
 		else
 			coordinate = 0;
 
-		f64 value = coordinate;
+		if (coordinate - previouse_coordinate > boundary[dim])
+		{
+			shift -= 1;
+			printf("coordinate %f- previouse_coordinate %f > boundary[dim] %f shift %d\n", coordinate, previouse_coordinate, boundary[dim], shift);
+		}
+		if (coordinate - previouse_coordinate < -boundary[dim])
+		{
+			shift += 1;
+			printf("coordinate %f- previouse_coordinate %f < boundary[dim] %f shift %d\n", coordinate, previouse_coordinate, boundary[dim], shift);
+		}
+
+		f64 value = coordinate + 2*shift*boundary[dim];
 		plot->AddData(loop, value);
 
 		mt_a1 = mt_a2 = mt_a3 = NULL;
+		previouse_coordinate = coordinate;
 	}
 
 	plot->Finalize();
diff -Nur ./ghemical-3.0.0.original/src/project.h ./ghemical-3.0.0/src/project.h
--- ./ghemical-3.0.0.original/src/project.h	2023-02-07 11:21:33.665100938 +0000
+++ ./ghemical-3.0.0/src/project.h	2023-02-07 16:25:52.680621680 +0000
@@ -376,6 +376,7 @@
 	void TrajView_VeloncityDistribution2D(i32s divx, i32s divy, f64 dt);
 	void TrajView_CoordinateDifferencePlot(i32s ind1, i32s ind2, i32s dim);
 	void TrajView_CoordinatePlot(i32s ind, i32s dim);
+	void TrajView_MoleculeCoordinatePlot(enum molgrouptype molgrouptype, i32s ind_mol, i32s dim, i32s crd_type);
 	void TrajView_DistancePlot(i32s inda, i32s indb);
 	void TrajView_AnglePlot(i32s inda, i32s indb, i32s indc);
 
diff -Nur ./ghemical-3.0.0.original/src/res_gtk/gtk_moldyn_dialog.glade ./ghemical-3.0.0/src/res_gtk/gtk_moldyn_dialog.glade
--- ./ghemical-3.0.0.original/src/res_gtk/gtk_moldyn_dialog.glade	2023-02-11 12:52:01.926245353 +0000
+++ ./ghemical-3.0.0/src/res_gtk/gtk_moldyn_dialog.glade	2023-02-20 22:14:54.913407306 +0000
@@ -439,13 +439,55 @@
               </packing>
             </child>
             <child>
-              <widget class="GtkCheckButton" id="checkbutton_box_optimization">
+              <widget class="GtkHBox" id="hbox5">
                 <property name="visible">True</property>
-                <property name="can_focus">True</property>
-                <property name="label" translatable="yes">box optimization</property>
-                <property name="use_underline">True</property>
-                <property name="response_id">0</property>
-                <property name="draw_indicator">True</property>
+                <property name="can_focus">False</property>
+                <property name="orientation">vertical</property>
+                <child>
+                  <widget class="GtkRadioButton" id="radiobutton_box_optimization_0">
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="label" translatable="yes">no box optimization</property>
+                    <property name="use_underline">True</property>
+                    <property name="response_id">0</property>
+                    <property name="draw_indicator">True</property>
+                  </widget>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">False</property>
+                    <property name="position">0</property>
+                  </packing>
+                </child>
+                <child>
+                  <widget class="GtkRadioButton" id="radiobutton_box_optimization_1">
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="label" translatable="yes">box optimization always</property>
+                    <property name="use_underline">True</property>
+                    <property name="response_id">1</property>
+                    <property name="draw_indicator">True</property>
+                  </widget>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">False</property>
+                    <property name="position">1</property>
+                  </packing>
+                </child>
+                <child>
+                  <widget class="GtkRadioButton" id="radiobutton_box_optimization_2">
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="label" translatable="yes">box optimization equilibration</property>
+                    <property name="use_underline">True</property>
+                    <property name="response_id">2</property>
+                    <property name="draw_indicator">True</property>
+                  </widget>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">False</property>
+                    <property name="position">2</property>
+                  </packing>
+                </child>
               </widget>
               <packing>
                 <property name="expand">False</property>

