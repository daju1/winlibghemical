diff -Nur ./libghemical-3.0.0.original/src/model.cpp ./libghemical-3.0.0/src/model.cpp
--- ./libghemical-3.0.0.original/src/model.cpp	2023-02-07 11:21:33.857100933 +0000
+++ ./libghemical-3.0.0/src/model.cpp	2023-02-07 18:16:34.080447359 +0000
@@ -53,6 +53,7 @@
 #include <iomanip>
 #include <sstream>
 #include <strstream>
+#include <map>
 using namespace std;
 
 #ifdef WIN32
@@ -159,7 +160,8 @@
 	traj_num_atoms = NOT_DEFINED;
 	total_traj_frames = NOT_DEFINED;
 	current_traj_frame = NOT_DEFINED;
-	trajectory_version = 14;
+	trajectory_version = 15;
+	frame_save_frq = 10000;
 	
 	verbosity = 3;
 	
@@ -1151,6 +1153,252 @@
 /*##############################################*/
 /*##############################################*/
 
+void model::MakeMoleculesGroups(std::list<struct molgroup>& molgroups)
+{
+	iter_bl itb;
+
+	i32s n1, nmol;
+	bool iscarbon1;
+	bool iscarbon2;
+	i32s index1, index2;
+	std::map<i32s, molecule>::iterator itmol;
+	std::map<i32s, molecule>::iterator itmol1;
+	std::map<i32s, molecule>::iterator itmol2;
+
+	UpdateIndex();
+
+	std::map<i32s, molecule> mols;
+
+	for (itb = this->GetBondsBegin();
+		itb != this->GetBondsEnd();
+		++itb)
+	{
+		atom * at1 = (* itb).atmr[0];
+		atom * at2 = (* itb).atmr[1];
+
+		iscarbon1 = 6 == at1->el.GetAtomicNumber();
+		iscarbon2 = 6 == at2->el.GetAtomicNumber();
+
+		index1 = at1->index;
+		index2 = at2->index;
+
+		i32s found1 = NOT_DEFINED;
+		i32s found2 = NOT_DEFINED;
+
+		for (itmol = mols.begin();
+			itmol != mols.end();
+			itmol++)
+		{
+			std::list<i32s>::iterator it  = (*itmol).second.natoms.begin();
+			std::list<i32s>::iterator end = (*itmol).second.natoms.end();
+			for(; it != end; ++it)
+			{
+				if ((*it) == index1)
+				{
+					found1 = (*itmol).first;
+				}
+				if ((*it) == index2)
+				{
+					found2 = (*itmol).first;
+				}
+			}
+		}
+
+		if (NOT_DEFINED == found1 &&
+			NOT_DEFINED == found2)
+		{
+			i32s id = mols.size();
+			mols.insert(std::pair<i32s, molecule>(id,
+				molecule(iscarbon1 ? 1 : 0, index1)));
+			itmol = mols.find(id);
+			(* itmol).second.natoms.push_back(index2);
+			(* itmol).second.ncarbons += iscarbon2 ? 1 : 0;
+		}
+		else
+		{
+			if (NOT_DEFINED == found1)
+			{
+				i32s id = found2;
+				itmol = mols.find(id);
+				(* itmol).second.natoms.push_back(index1);
+				(* itmol).second.ncarbons += iscarbon1 ? 1 : 0;
+			}
+			if (NOT_DEFINED == found2)
+			{
+				i32s id = found1;
+				itmol = mols.find(id);
+				(* itmol).second.natoms.push_back(index2);
+				(* itmol).second.ncarbons += iscarbon2 ? 1 : 0;
+			}
+		}
+	}
+
+	for (itb = this->GetBondsBegin();
+		itb != this->GetBondsEnd();
+		++itb)
+	{
+		atom * at1 = (* itb).atmr[0];
+		atom * at2 = (* itb).atmr[1];
+
+		iscarbon1 = 6 == at1->el.GetAtomicNumber();
+		iscarbon2 = 6 == at2->el.GetAtomicNumber();
+
+		index1 = at1->index;
+		index2 = at2->index;
+
+		i32s found1 = NOT_DEFINED;
+		i32s found2 = NOT_DEFINED;
+
+		for (itmol = mols.begin();
+			itmol != mols.end();
+			itmol++)
+		{
+			std::list<i32s>::iterator it  = (*itmol).second.natoms.begin();
+			std::list<i32s>::iterator end = (*itmol).second.natoms.end();
+			for(; it != end; ++it)
+			{
+				if ((*it) == index1)
+				{
+					found1 = (*itmol).first;
+				}
+				if ((*it) == index2)
+				{
+					found2 = (*itmol).first;
+				}
+			}
+		}
+
+		if (! (NOT_DEFINED == found1 && NOT_DEFINED == found2))
+		{
+			if (found1 < found2 )
+			{
+				itmol2 = mols.find(found2);
+				itmol1 = mols.find(found1);
+
+				// 2 > 1
+				std::list<i32s>::iterator it  = (* itmol2).second.natoms.begin();
+				std::list<i32s>::iterator end = (* itmol2).second.natoms.end();
+				for(; it != end;++it)
+				{
+					(* itmol1).second.natoms.push_back(*it);
+				}
+				(* itmol1).second.ncarbons += (* itmol2).second.ncarbons;
+
+				mols.erase(itmol2);
+			}
+
+			if (found2 < found1 )
+			{
+				itmol2 = mols.find(found2);
+				itmol1 = mols.find(found1);
+
+				// 1 > 2
+				std::list<i32s>::iterator it  = (* itmol1).second.natoms.begin();
+				std::list<i32s>::iterator end = (* itmol1).second.natoms.end();
+				for(; it != end;++it)
+				{
+					(* itmol2).second.natoms.push_back(*it);
+				}
+				(* itmol2).second.ncarbons += (* itmol1).second.ncarbons;
+
+				mols.erase(itmol1);
+			}
+		}
+	}
+
+	for (itb = this->GetBondsBegin();
+		itb != this->GetBondsEnd();
+		++itb)
+	{
+		atom * at1 = (* itb).atmr[0];
+		atom * at2 = (* itb).atmr[1];
+
+		iscarbon1 = 6 == at1->el.GetAtomicNumber();
+		iscarbon2 = 6 == at2->el.GetAtomicNumber();
+
+		index1 = at1->index;
+		index2 = at2->index;
+
+		i32s found1 = NOT_DEFINED;
+		i32s found2 = NOT_DEFINED;
+
+		for (itmol = mols.begin();
+			itmol != mols.end();
+			itmol++)
+		{
+			std::list<i32s>::iterator it  = (*itmol).second.natoms.begin();
+			std::list<i32s>::iterator end = (*itmol).second.natoms.end();
+			for(; it != end; ++it)
+			{
+				if ((*it) == index1)
+				{
+					found1 = (*itmol).first;
+				}
+				if ((*it) == index2)
+				{
+					found2 = (*itmol).first;
+				}
+			}
+		}
+
+		if (! (NOT_DEFINED == found1 && NOT_DEFINED == found2))
+		{
+			at1->id[0] = found1;
+			at2->id[0] = found2;
+		}
+	}
+
+	iter_al it1;
+	bool iscarbon;
+
+	std::map<i32s, molecule> molecules;
+	for (n1 = 0, it1 = this->GetAtomsBegin();
+		 n1 < this->GetAtomCount() && it1 != this->GetAtomsEnd();
+		 n1++, it1++)
+	{
+		nmol = (* it1).id[0];
+		iscarbon = 6 == (* it1).el.GetAtomicNumber();
+		itmol = molecules.find(nmol);
+		if (itmol == molecules.end())
+		{
+			molecules.insert(std::pair<i32s, molecule>((* it1).id[0], molecule(iscarbon ? 1 : 0, n1)));
+		}
+		else
+		{
+			(* itmol).second.ncarbons += iscarbon ? 1 : 0;
+			(* itmol).second.natoms.push_back(n1);
+		}
+	}
+
+	molgroups.push_back(molgroup(GAS));
+	for (itmol = molecules.begin(); itmol != molecules.end(); itmol++)
+	{
+		if ((*itmol).second.ncarbons > 2)
+		{
+			molgroups.push_back(molgroup(MEMBRANE_OR_GLOBULE, (*itmol).second.natoms));
+		}
+		else
+		{
+			std::list<i32s>::iterator it = (*itmol).second.natoms.begin();
+			std::list<i32s>::iterator end = (*itmol).second.natoms.end();
+			for(; it != end; ++it)
+			{
+				molgroups.front().natoms.push_back(*it);
+			}
+		}
+	}
+
+	printf("molgroups size = %d\n", molgroups.size());
+	for ( std::list<molgroup>::iterator it_mlgr = molgroups.begin();
+		it_mlgr != molgroups.end(); ++it_mlgr)
+	{
+		printf("%s natoms size = %d\n", (GAS == (*it_mlgr).molgrouptype ? "gas" : "membrane or globule"), (*it_mlgr).natoms.size());
+	}
+}
+
+/*##############################################*/
+/*##############################################*/
+
 void model::GetRange(i32s ind, i32s value, iter_al * result)
 {
 	iter_al range[2] = { atom_list.begin(), atom_list.end() };
@@ -3258,7 +3506,6 @@
 	ofstream ofile;		// the trajectory file...
 	ofile.open(param.filename, ios::out | ios::binary);
 	
-	const int frame_save_frq = 10000;
 	const int total_frames = param.nsteps_s / frame_save_frq;
 	
 	WriteTrajectoryHeader(ofile, total_frames, dyn, frame_save_frq);
@@ -4657,13 +4904,24 @@
 			PrintToLog(str.str().c_str());
 		}
 
-		if (trajectory_version > 11)
+		if (trajectory_version > 11 && trajectory_version <= 15)
 		{
-			float tstep;
-			trajfile->read((char *) & tstep, sizeof(tstep));
+			trajfile->read((char *) & time_step_between_traj_records, sizeof(time_step_between_traj_records));
 			stringstream str;
-			str << _("time step between traj records ") << (tstep / 1000) << _(" * 1.0E-12 s") << endl
-				<< _("the trajectory common time is ") << (tstep * (real_frames - 1) / 1000000) << _(" * 1.0E-9 s") << endl << ends;
+			str << _("time step between traj records ") << (time_step_between_traj_records / 1000) << _(" * 1.0E-12 s") << endl
+				<< _("the trajectory common time is ") << (time_step_between_traj_records * (real_frames - 1) / 1000000) << _(" * 1.0E-9 s") << endl << ends;
+			PrintToLog(str.str().c_str());
+		}
+		else
+		{
+			trajfile->read((char *) & traj_frame_save_frq, sizeof(traj_frame_save_frq));
+			trajfile->read((char *) & traj_tstep1, sizeof(traj_tstep1));
+			time_step_between_traj_records = traj_tstep1 * traj_frame_save_frq;
+			stringstream str;
+			str << _("traj_frame_save_frq ") << traj_frame_save_frq 
+				<< _(" traj_tstep1 ") << traj_tstep1 << endl
+				<< _("time step between traj records ") << (time_step_between_traj_records / 1000) << _(" * 1.0E-12 s") << endl
+				<< _("the trajectory common time is ") << (time_step_between_traj_records * (real_frames - 1) / 1000000) << _(" * 1.0E-9 s") << endl << ends;
 			PrintToLog(str.str().c_str());
 		}
 	}
@@ -4678,11 +4936,10 @@
 	
 	trajfile->seekg(place, ios::beg);
 
-	float tmp;
-
 	if (trajectory_version > 10) {
 
 		float boundary[3];
+		float tmp;
 		trajfile->read((char *) & tmp, sizeof(tmp)); boundary[0] = tmp;
 		trajfile->read((char *) & tmp, sizeof(tmp)); boundary[1] = tmp;
 		trajfile->read((char *) & tmp, sizeof(tmp)); boundary[2] = tmp;
@@ -4699,10 +4956,76 @@
 			saved_boundary_potential_rad_solvent = boundary[2];
 		}
 	}
-	
+
+	if (15 == trajectory_version || 17 == trajectory_version)
+	{
+		for (iter_al it1 = atom_list.begin();it1 != atom_list.end();it1++)
+		{
+		//	if ((* it1).flags & ATOMFLAG_IS_HIDDEN) continue;	// currently all coordinates are written...
+			f64 tmp;
+
+			f64 cdata[3];
+			f64 vdata[3];
+			f64 adata[3];
+			f64 fdata[3];
+			f64 cumsum_vdata[3];
+			f64 cumsum_adata[3];
+			f64 cumsum_fdata[3];
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				cdata[t4] = tmp;
+			}
+
+			(* it1).SetCRD(0, cdata[0], cdata[1], cdata[2]);
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				vdata[t4] = tmp;
+			}
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				adata[t4] = tmp;
+			}
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				fdata[t4] = tmp;
+			}
+
+			if (17 == trajectory_version)
+			{
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & tmp, sizeof(tmp));
+					cumsum_vdata[t4] = tmp;
+				}
+
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & tmp, sizeof(tmp));
+					cumsum_adata[t4] = tmp;
+				}
+
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & tmp, sizeof(tmp));
+					cumsum_fdata[t4] = tmp;
+				}
+			}
+		}
+		return;
+	}
+
 	for (iter_al it1 = atom_list.begin();it1 != atom_list.end();it1++)
 	{
 	//	if ((* it1).flags & ATOMFLAG_IS_HIDDEN) continue;	// currently all coordinates are written...
+		float tmp;
 		
 		fGL cdata[3];
 		for (i32s t4 = 0; t4 < 3; t4++)
@@ -4743,6 +5066,31 @@
 				fdata[t4] = tmp;
 			}
 		}
+
+		if (16 == trajectory_version)
+		{
+			fGL cumsum_vdata[3];
+			fGL cumsum_adata[3];
+			fGL cumsum_fdata[3];
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				cumsum_vdata[t4] = tmp;
+			}
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				cumsum_adata[t4] = tmp;
+			}
+
+			for (i32s t4 = 0; t4 < 3; t4++)
+			{
+				trajfile->read((char *) & tmp, sizeof(tmp));
+				cumsum_fdata[t4] = tmp;
+			}
+		}
 	}
 }
 
@@ -4765,10 +5113,19 @@
 		return (8 + 2 * sizeof(int));
 	}
 
+	if (trajectory_version <= 15)
+	{
+		// file_id
+		// number_of_atoms,  total_frames
+		// time_step_between_traj_records
+		return (8 + 2 * sizeof(int) + sizeof(float));
+	}
+
 	// file_id
 	// number_of_atoms,  total_frames
-	// tstep
-	return (8 + 2 * sizeof(int) + sizeof(float));
+	// frame_save_frq, tstep
+	return (8 + 3 * sizeof(int) + sizeof(double));
+
 }
 
 size_t model::GetTrajectoryEnergySize()
@@ -4807,6 +5164,27 @@
 			+ 12 * traj_num_atoms * sizeof(float)); //crd + force + vel + acc
 	}
 
+	if (trajectory_version == 15) {
+		return (GetTrajectoryEnergySize()
+			+ 3 * sizeof(float) // boundary
+			+ 12 * traj_num_atoms * sizeof(f64)); //crd + force + vel + acc
+	}
+
+
+	if (trajectory_version == 16) {
+		return (GetTrajectoryEnergySize()
+			+ 3 * sizeof(float) // boundary
+			+ 12 * traj_num_atoms * sizeof(float) //crd + force + vel + acc
+			+ 9  * traj_num_atoms * sizeof(float)); //cumsum_force + cumsum_vel + cumsum_acc
+	}
+
+	if (trajectory_version == 17) {
+		return (GetTrajectoryEnergySize()
+			+ 3 * sizeof(float) // boundary
+			+ 12 * traj_num_atoms * sizeof(f64) //crd + force + vel + acc
+			+ 9  * traj_num_atoms * sizeof(f64)); //cumsum_force + cumsum_vel + cumsum_acc
+	}
+
 	return -1;
 }
 
@@ -4830,6 +5208,16 @@
 	current_traj_frame = p1;
 }
 
+void model::SetTrajectoryVersionBeforeMoldyn(i32s version)
+{
+	trajectory_version = version;
+}
+
+void model::SetTrajectoryFrameSaveFrq(int frq)
+{
+	frame_save_frq = frq;
+}
+
 void model::WriteTrajectoryHeader(ofstream & ofile, int total_frames, moldyn * dyn, int frame_save_freq)
 {
 	char file_id[10];
@@ -4842,10 +5230,16 @@
 	ofile.write((char *) & number_of_atoms, sizeof(number_of_atoms));	// number of atoms, int.
 	ofile.write((char *) & total_frames, sizeof(total_frames));		// total number of frames, int.
 
-	if (trajectory_version > 11)
+	if (trajectory_version > 11 && trajectory_version <= 15)
+	{
+		float _time_step_between_traj_records = dyn->tstep1 * frame_save_freq;
+		ofile.write((char *) & _time_step_between_traj_records, sizeof(_time_step_between_traj_records));
+	}
+	else if (trajectory_version > 15)
 	{
-		float tstep = dyn->tstep1 * frame_save_freq;
-		ofile.write((char *) & tstep, sizeof(tstep));
+		double tstep1 = dyn->tstep1;
+		ofile.write((char *) & frame_save_freq, sizeof(frame_save_freq));
+		ofile.write((char *) & tstep1, sizeof(tstep1));
 	}
 }
 
diff -Nur ./libghemical-3.0.0.original/src/model.h ./libghemical-3.0.0/src/model.h
--- ./libghemical-3.0.0.original/src/model.h	2023-02-11 20:23:48.869682815 +0000
+++ ./libghemical-3.0.0/src/model.h	2023-02-12 09:48:02.652681426 +0000
@@ -109,6 +109,11 @@
 	i32s total_traj_frames;		// trajectory files...
 	i32s current_traj_frame;	// trajectory files...
 
+	float time_step_between_traj_records;
+	int frame_save_frq;
+	double traj_tstep1;
+	int traj_frame_save_frq;
+
 	i32s trajectory_version;
 	
 	public:
@@ -320,6 +325,8 @@
 	iter_al FindAtomByIndex(i32s);
 	iter_CDl FindAtomConstraint(atom &);
 	
+	void MakeMoleculesGroups(std::list<struct molgroup>& molgroups);
+	
 	void GetRange(i32s, i32s, iter_al *);	///< This is just a default version of GetRange() using the full range of atom list iterators...
 	
 /// GetRange is used to get a range of atoms that form molecules, residues etc...
@@ -435,7 +442,9 @@
 	
 	i32s GetCurrentFrame(void);
 	void SetCurrentFrame(i32s);
-	
+
+	void SetTrajectoryVersionBeforeMoldyn(i32s version);
+	void SetTrajectoryFrameSaveFrq(int frq);
 	void WriteTrajectoryHeader(ofstream &, int, moldyn *, int);
 	void WriteTrajectoryFrame(ofstream &, moldyn *);
 	
diff -Nur ./libghemical-3.0.0.original/src/moldyn.cpp ./libghemical-3.0.0/src/moldyn.cpp
--- ./libghemical-3.0.0.original/src/moldyn.cpp	2023-02-11 12:52:01.938245352 +0000
+++ ./libghemical-3.0.0/src/moldyn.cpp	2023-02-12 09:19:34.064716884 +0000
@@ -41,7 +41,11 @@
 	
 	vel = new f64[eng->GetAtomCount() * 3];			// [1.0e+3 m/s]
 	acc = new f64[eng->GetAtomCount() * 3];			// [1.0e+12 m/s^2]
-	
+
+	cumsum_vel = new f64[eng->GetAtomCount() * 3];			// [1.0e+3 m/s]
+	cumsum_acc = new f64[eng->GetAtomCount() * 3];			// [1.0e+12 m/s^2]
+	cumsum_f   = new f64[eng->GetAtomCount() * 3];			// [1.0e+3 m/s]
+
 	mass = new f64[eng->GetAtomCount()];			// [kg/mol]
 	
 	locked = new char[eng->GetAtomCount()];
@@ -73,6 +77,10 @@
 		{
 			vel[counter * 3 + n1] = 0.0;
 			acc[counter * 3 + n1] = 0.0;
+
+			cumsum_vel[counter * 3 + n1] = 0.0;
+			cumsum_acc[counter * 3 + n1] = 0.0;
+			cumsum_f  [counter * 3 + n1] = 0.0;
 		}
 		
 		counter++;
@@ -95,6 +103,10 @@
 	delete[] vel;
 	delete[] acc;
 	
+	delete[] cumsum_vel;
+	delete[] cumsum_acc;
+	delete[] cumsum_f;
+
 	delete[] mass;
 	
 	delete[] locked;
@@ -122,7 +134,7 @@
 		for (i32s n2 = 0;n2 < 3;n2++)
 		{
 			f64 tmpA = acc[n1 * 3 + n2];
-			
+
 			f64 tmp1 = tstep1 * vel[n1 * 3 + n2] * 1.0e-3;
 			f64 tmp2 = tstep2 * tmpA * 0.5e-9;
 			
@@ -150,14 +162,19 @@
 		}
 		else
 		{
-			acc[n1 * 3 + 0] = -eng->d1[n1 * 3 + 0] / mass[n1];
-			acc[n1 * 3 + 1] = -eng->d1[n1 * 3 + 1] / mass[n1];
-			acc[n1 * 3 + 2] = -eng->d1[n1 * 3 + 2] / mass[n1];
-			
-			vel[n1 * 3 + 0] += tstep1 * acc[n1 * 3 + 0] * 0.5e-6;
-			vel[n1 * 3 + 1] += tstep1 * acc[n1 * 3 + 1] * 0.5e-6;
-			vel[n1 * 3 + 2] += tstep1 * acc[n1 * 3 + 2] * 0.5e-6;
+			for (i32s n2 = 0;n2 < 3;n2++)
+			{
+				acc[n1 * 3 + n2] = -eng->d1[n1 * 3 + n2] / mass[n1];
+				vel[n1 * 3 + n2] += tstep1 * acc[n1 * 3 + n2] * 0.5e-6;
+
+				cumsum_vel[n1 * 3 + n2] += vel[n1 * 3 + n2];
+				cumsum_acc[n1 * 3 + n2] += acc[n1 * 3 + n2];
+			}
 		}
+		for (i32s n2 = 0;n2 < 3;n2++)
+		{
+			cumsum_f[n1 * 3 + n2] += eng->d1[n1 * 3 + n2];
+		}
 	}
 	
 	f64 ekinCOMP[3];
@@ -443,55 +460,8 @@
 void moldyn::ForceMoleculesMomentumToZero()
 {
 	model * mdl = eng->GetSetup()->GetModel();
-
-	iter_al it1;
-	iter_al range1[2];
-	iter_al range2[2];
-	i32s n1, nmol;
-	bool iscarbon;
-
-
-
-	std::map<i32s, molecule> molecules;
-	std::map<i32s, molecule>::iterator itmol;
-	for (n1 = 0, it1 = mdl->GetAtomsBegin();
-		 n1 < eng->GetAtomCount() && it1 != mdl->GetAtomsEnd();
-		 n1++, it1++)
-	{
-		nmol = (* it1).id[0];
-		iscarbon = 6 == (* it1).el.GetAtomicNumber();
-		itmol = molecules.find(nmol);
-		if (itmol == molecules.end())
-		{
-			molecules.insert(std::pair<i32s, molecule>((* it1).id[0], molecule(iscarbon ? 1 : 0, n1)));
-		}
-		else
-		{
-			(* itmol).second.ncarbons += iscarbon ? 1 : 0;
-			(* itmol).second.natoms.push_back(n1);
-		}
-	}
-
-
 	std::list<struct molgroup> molgroups;
-	molgroups.push_back(molgroup(GAS));
-	for (itmol = molecules.begin(); itmol != molecules.end(); itmol++)
-	{
-		if ((*itmol).second.ncarbons > 2)
-		{
-			molgroups.push_back(molgroup(MEMBRANE_OR_GLOBULE, (*itmol).second.natoms));
-		}
-		else
-		{
-			std::list<i32s>::iterator it = (*itmol).second.natoms.begin();
-			std::list<i32s>::iterator end = (*itmol).second.natoms.end();
-			for(; it != end; ++it)
-			{
-				molgroups.front().natoms.push_back(*it);
-			}
-		}
-	}
-
+	mdl->MakeMoleculesGroups(molgroups);
 	for ( std::list<molgroup>::iterator it_mlgr = molgroups.begin();
 		it_mlgr != molgroups.end(); ++it_mlgr)
 	{
@@ -499,8 +469,6 @@
 	}
 }
 
-
-
 void moldyn::SumModelImpuls(f64 * sum_p)
 {
 	for (i32s n2 = 0;n2 < 3;n2++) sum_p[n2] = 0.0;
@@ -516,41 +484,117 @@
 
 void moldyn::SaveTrajectoryFrame(ofstream& ofile, i32s trajectory_version)
 {
-	float t1a;
-	const int number_of_atoms = eng->GetAtomCount();
-	for (i32s tt1 = 0;tt1 < number_of_atoms;tt1++)
+	if (trajectory_version < 15 || 16 == trajectory_version)
 	{
-		for (i32s tt2 = 0;tt2 < 3;tt2++)
+		float t1a;
+		const int number_of_atoms = eng->GetAtomCount();
+		for (i32s tt1 = 0;tt1 < number_of_atoms;tt1++)
 		{
-			t1a = eng->crd[tt1 * 3 + tt2];
-			ofile.write((char *) & t1a, sizeof(t1a));
-		}
+			for (i32s tt2 = 0;tt2 < 3;tt2++)
+			{
+				t1a = eng->crd[tt1 * 3 + tt2];
+				ofile.write((char *) & t1a, sizeof(t1a));
+			}
+
+			if (trajectory_version > 12)
+			{
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = vel[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+			}
+
+			if (trajectory_version > 13)
+			{
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = acc[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+			}
+
+			if (trajectory_version > 11)
+			{
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = eng->d1[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+			}
 
-		if (trajectory_version > 12)
+			if (16 == trajectory_version)
+			{
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_vel[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_acc[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_f[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+			}
+		}
+	}
+	else if (15 == trajectory_version || 17 == trajectory_version)
+	{
+		f64 t1a;
+		const int number_of_atoms = eng->GetAtomCount();
+		for (i32s tt1 = 0;tt1 < number_of_atoms;tt1++)
 		{
 			for (i32s tt2 = 0;tt2 < 3;tt2++)
 			{
+				t1a = eng->crd[tt1 * 3 + tt2];
+				ofile.write((char *) & t1a, sizeof(t1a));
+			}
+
+			for (i32s tt2 = 0;tt2 < 3;tt2++)
+			{
 				t1a = vel[tt1 * 3 + tt2];
 				ofile.write((char *) & t1a, sizeof(t1a));
 			}
-		}
 
-		if (trajectory_version > 13)
-		{
 			for (i32s tt2 = 0;tt2 < 3;tt2++)
 			{
 				t1a = acc[tt1 * 3 + tt2];
 				ofile.write((char *) & t1a, sizeof(t1a));
 			}
-		}
 
-		if (trajectory_version > 11)
-		{
 			for (i32s tt2 = 0;tt2 < 3;tt2++)
 			{
 				t1a = eng->d1[tt1 * 3 + tt2];
 				ofile.write((char *) & t1a, sizeof(t1a));
 			}
+
+			if (17 == trajectory_version)
+			{
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_vel[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_acc[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+
+				for (i32s tt2 = 0;tt2 < 3;tt2++)
+				{
+					t1a = cumsum_f[tt1 * 3 + tt2];
+					ofile.write((char *) & t1a, sizeof(t1a));
+				}
+			}
 		}
 	}
 }
diff -Nur ./libghemical-3.0.0.original/src/moldyn.h ./libghemical-3.0.0/src/moldyn.h
--- ./libghemical-3.0.0.original/src/moldyn.h	2023-02-11 12:52:01.934245352 +0000
+++ ./libghemical-3.0.0/src/moldyn.h	2023-02-12 09:04:32.860735586 +0000
@@ -163,7 +163,11 @@
 	
 	f64 * vel;			// [1.0e+3 m/s]
 	f64 * acc;			// [1.0e+12 m/s^2]
-	
+
+	f64 * cumsum_vel;
+	f64 * cumsum_acc;
+	f64 * cumsum_f;
+
 	f64 * mass;			// [kg/mol]
 	
 	char * locked;
diff -Nur ./ghemical-3.0.0.original/src/project.cpp ./ghemical-3.0.0/src/project.cpp
--- ./ghemical-3.0.0.original/src/project.cpp	2023-02-07 11:21:33.729100937 +0000
+++ ./ghemical-3.0.0/src/project.cpp	2023-02-07 18:57:35.216382759 +0000
@@ -1639,6 +1639,25 @@
 		return;
 	}
 	
+
+	if (!strcmp("make_plot_mol_crd", kw1))
+	{
+		char kw2[32]; istr >> kw2;	// A
+		char kw3[32]; istr >> kw3;	// B
+		char kw4[32]; istr >> kw4;	// B
+		char kw5[32]; istr >> kw5;	// B
+
+		char ** endptr = NULL;
+
+		i32s molgrouptype = strtol(kw2, endptr, 10);
+		i32s ind_mol      = strtol(kw3, endptr, 10);
+		i32s dim          = strtol(kw4, endptr, 10);
+		i32s crd_type     = strtol(kw5, endptr, 10);
+
+		TrajView_MoleculeCoordinatePlot((enum molgrouptype)molgrouptype, ind_mol, dim, crd_type);
+		return;
+	}
+
 	if (!strcmp("sel_atoms_with_flag", kw1))
 	{
 		char kw2[32]; istr >> kw2;	
@@ -3695,6 +3714,492 @@
 	Message(str.str().c_str());
 }
 
+void project::TrajView_MoleculeCoordinatePlot(enum molgrouptype molgrouptype, i32s ind_mol, i32s dim, i32s crd_type)
+{
+	if (!this->GetTrajectoryFile())
+	{
+		this->ErrorMessage(_("Trajectory file does not opened?"));
+		return;
+	}
+
+	const char * crd_name [] = {"coordinate", "velocity", "acceleration", "force"};
+
+	const char * s1 = "frame(num)"; const char * sv = "distance (nm)";
+	p1dview_wcl * plot = AddPlot1DClient(s1, sv, true);
+
+	float ekin;
+	float epot;
+
+
+	i32s shift = 0;
+	f64 first_coordinate = 0.0;
+	f64 previouse_coordinate = 0.0;
+	f64 sum_d_coordinate_error = 0.0;
+	f64 sum_coordinate = 0.0;
+	f64 sum_velocity = 0.0;
+	f64 previouse_velocity = 0.0;
+	f64 sum_d_velocity_error = 0.0;
+	f64 previouse_acceleration = 0.0;
+	f64 sum_acceleration = 0.0;
+	f64 sum_force = 0.0;
+
+	std::list<struct molgroup> molgroups;
+	this->MakeMoleculesGroups(molgroups);
+
+	size_t natoms = atom_list.size();
+	std::vector<f64> c_data; c_data.resize(natoms * 3);
+	std::vector<f64> v_data; v_data.resize(natoms * 3);
+	std::vector<f64> a_data; a_data.resize(natoms * 3);
+	std::vector<f64> f_data; f_data.resize(natoms * 3);
+
+	std::vector<f64> cumsum_v_data; cumsum_v_data.resize(natoms * 3);
+	std::vector<f64> cumsum_a_data; cumsum_a_data.resize(natoms * 3);
+	std::vector<f64> cumsum_f_data; cumsum_f_data.resize(natoms * 3);
+
+	i32s max_frames = this->GetTotalFrames();
+	for (i32s loop = 0; loop < max_frames; loop++)
+	{
+		this->SetCurrentFrame(loop);
+
+		i32s place = GetTrajectoryHeaderSize();						// skip the header...
+		place += GetTrajectoryFrameSize() * current_traj_frame;		// get the correct frame...
+		//place += GetTrajectoryEnergySize();							// skip epot and ekin...
+
+		trajfile->seekg(place, ios::beg);
+
+		trajfile->read((char *) & ekin, sizeof(ekin));
+		trajfile->read((char *) & epot, sizeof(epot));
+
+		float boundary[3];
+		if (trajectory_version > 10)
+		{
+			float tmp;
+			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[0] = tmp;
+			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[1] = tmp;
+			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[2] = tmp;
+			if (loop  ==  max_frames - 1) {
+				printf("boundary %f %f %f\n", boundary[0], boundary[1], boundary[2]);
+			}
+		}
+
+		i32s ind = 0;
+		mt_a1 = mt_a2 = mt_a3 = NULL;
+
+		for (iter_al it1 = atom_list.begin(); it1 != atom_list.end(); it1++)
+		{
+			f64 cdata[3];
+			f64 vdata[3];
+			f64 adata[3];
+			f64 fdata[3];
+
+			if (trajectory_version < 15)
+			{
+				float t1a;
+				for (i32s t4 = 0;t4 < 3;t4++)
+				{
+					trajfile->read((char *) & t1a, sizeof(t1a));
+					cdata[t4] = t1a;
+					c_data[3 * ind + t4] = t1a;
+				}
+
+				if (trajectory_version > 12)
+				{
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						vdata[t4] = t1a;
+						v_data[3 * ind + t4] = t1a;
+					}
+				}
+
+				if (trajectory_version > 13)
+				{
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						adata[t4] = t1a;
+						a_data[3 * ind + t4] = t1a;
+					}
+				}
+
+				if (trajectory_version > 11)
+				{
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						fdata[t4] = t1a;
+						f_data[3 * ind + t4] = t1a;
+					}
+				}
+
+				if (16 == trajectory_version)
+				{
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						vdata[t4] = t1a;
+						cumsum_v_data[3 * ind + t4] = t1a;
+					}
+
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						adata[t4] = t1a;
+						cumsum_a_data[3 * ind + t4] = t1a;
+					}
+
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						fdata[t4] = t1a;
+						cumsum_f_data[3 * ind + t4] = t1a;
+					}
+				}
+			}
+			else if (15 == trajectory_version || 17 == trajectory_version)
+			{
+				f64 t1a;
+				for (i32s t4 = 0;t4 < 3;t4++)
+				{
+					trajfile->read((char *) & t1a, sizeof(t1a));
+					cdata[t4] = t1a;
+					c_data[3 * ind + t4] = t1a;
+				}
+
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & t1a, sizeof(t1a));
+					vdata[t4] = t1a;
+					v_data[3 * ind + t4] = t1a;
+				}
+
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & t1a, sizeof(t1a));
+					adata[t4] = t1a;
+					a_data[3 * ind + t4] = t1a;
+				}
+
+				for (i32s t4 = 0; t4 < 3; t4++)
+				{
+					trajfile->read((char *) & t1a, sizeof(t1a));
+					fdata[t4] = t1a;
+					f_data[3 * ind + t4] = t1a;
+				}
+
+				if (17 == trajectory_version)
+				{
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						vdata[t4] = t1a;
+						cumsum_v_data[3 * ind + t4] = t1a;
+					}
+
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						adata[t4] = t1a;
+						cumsum_a_data[3 * ind + t4] = t1a;
+					}
+
+					for (i32s t4 = 0; t4 < 3; t4++)
+					{
+						trajfile->read((char *) & t1a, sizeof(t1a));
+						fdata[t4] = t1a;
+						cumsum_f_data[3 * ind + t4] = t1a;
+					}
+				}
+			}
+
+			//printf("%d -f/a %f %f %f\n", ind
+			//	, -fdata[0]/adata[0]
+			//	, -fdata[1]/adata[1]
+			//	, -fdata[2]/adata[2]
+			//	);
+
+			//printf("%d -f / a %f %f %f %f %f\n", ind
+			//	, -f_data[3 * ind + 0]/a_data[3 * ind + 0]
+			//	, -f_data[3 * ind + 1]/a_data[3 * ind + 1]
+			//	, -f_data[3 * ind + 2]/a_data[3 * ind + 2]
+			//	, -f_data[3 * ind + 2],a_data[3 * ind + 2]
+			//	);
+
+			/*printf("v, a %f %f %f %f %f %f\n"
+				, vdata[0],adata[0]
+				, vdata[1],adata[1]
+				, vdata[2],adata[2]
+				);*/
+
+			/*
+			acc[n1 * 3 + 0] = -eng->d1[n1 * 3 + 0] / mass[n1];
+			acc[n1 * 3 + 1] = -eng->d1[n1 * 3 + 1] / mass[n1];
+			acc[n1 * 3 + 2] = -eng->d1[n1 * 3 + 2] / mass[n1];
+			*/
+
+			ind++;
+		}
+
+		f64 coordinate = 0;
+		f64 velocity = 0;
+		f64 acceleration = 0;
+		f64 force = 0;
+
+		f64 cumsum_velocity = 0;
+		f64 cumsum_acceleration = 0;
+		f64 cumsum_force = 0;
+
+		i32s indmol=0;
+		for (std::list<molgroup>::iterator it_mlgr = molgroups.begin();
+			it_mlgr != molgroups.end(); ++it_mlgr)
+		{
+			if (molgrouptype != it_mlgr->molgrouptype)
+			{
+				continue;
+			}
+
+			if (ind_mol != indmol)
+			{
+				indmol++;
+				continue;
+			}
+
+			f64 crd, vel, acc, frc,
+				cumsum_vel, cumsum_acc, cumsum_frc,
+				sum_crd = 0.0, sum_vel = 0.0, sum_acc = 0.0, sum_frc = 0.0, 
+				sum_cumsum_vel = 0.0, sum_cumsum_acc = 0.0, sum_cumsum_frc = 0.0, 
+				pre_crd = 0.0, pre_vel = 0.0;
+
+			for (std::list<i32s>::iterator it = it_mlgr->natoms.begin();
+				it != it_mlgr->natoms.end(); ++it)
+			{
+				ind = *it;
+				crd = c_data[3 * ind + dim];
+				vel = v_data[3 * ind + dim];
+				acc = a_data[3 * ind + dim];
+				frc = f_data[3 * ind + dim];
+				cumsum_vel = cumsum_v_data[3 * ind + dim];
+				cumsum_acc = cumsum_a_data[3 * ind + dim];
+				cumsum_frc = cumsum_f_data[3 * ind + dim];
+
+			//printf("crd vel acc frc %f %f %f %f\n"
+			//	, crd, vel, acc, frc
+			//	);
+
+			//printf("ind %d dim %d -frc/acc %f %f %f\n", ind, dim
+			//	, -frc/acc
+			//	, -frc, acc
+			//	);
+
+				if (0 == crd_type)
+				{
+					//this->apply_periodic_cond(eng, test2);
+					if (crd - pre_crd > boundary[dim])
+					{
+						crd -= 2 * boundary[dim];
+					}
+					if (crd - pre_crd < -boundary[dim])
+					{
+						crd += 2 * boundary[dim];
+					}
+				}
+
+				sum_crd += crd;
+				pre_crd = crd;
+
+				sum_vel += vel;
+				pre_vel = vel;
+
+				sum_acc += acc;
+				sum_frc += frc;
+
+				sum_cumsum_vel += cumsum_vel;
+				sum_cumsum_acc += cumsum_acc;
+				sum_cumsum_frc += cumsum_frc;
+			}
+
+			//if (crd_type < 3) // crd, vel and acc, but not force
+			sum_crd /= it_mlgr->natoms.size();
+			sum_vel /= it_mlgr->natoms.size();
+			sum_acc /= it_mlgr->natoms.size();
+
+			sum_cumsum_vel /= it_mlgr->natoms.size();
+			sum_cumsum_acc /= it_mlgr->natoms.size();
+
+			coordinate   = sum_crd;
+			velocity     = sum_vel;
+			acceleration = sum_acc;
+			force        = sum_frc;
+
+			cumsum_velocity     = sum_cumsum_vel;
+			cumsum_acceleration = sum_cumsum_acc;
+			cumsum_force        = sum_cumsum_frc;
+
+			indmol++;
+		}
+
+		//if (0 == crd_type)
+		{
+			if (coordinate - previouse_coordinate > boundary[dim])
+			{
+				shift -= 1;
+				printf("coordinate %e - previouse_coordinate %e > boundary[dim] %e shift %d\n", coordinate, previouse_coordinate, boundary[dim], shift);
+			}
+			if (coordinate - previouse_coordinate < -boundary[dim])
+			{
+				shift += 1;
+				printf("coordinate %e - previouse_coordinate %f < boundary[dim] %e shift %d\n", coordinate, previouse_coordinate, boundary[dim], shift);
+			}
+			sum_coordinate = coordinate - first_coordinate;
+		}
+		//else
+		{
+			sum_velocity     += velocity;
+			sum_acceleration += acceleration;
+			sum_force        += force;
+		}
+
+		/*
+		f64 tstep1;		// timestep [fs] // [1.0e-15 s]
+		f64 tstep2;		// timestep ^ 2	 // [1.0e-30 s^2]		
+
+		f64 tmpA = acc[n1 * 3 + n2];
+		f64 tmp1 = tstep1 * vel[n1 * 3 + n2] * 1.0e-3;
+		f64 tmp2 = tstep2 * tmpA * 0.5e-9;
+
+		if (!locked[n1])
+		{
+			eng->crd[n1 * 3 + n2] += tmp1 + tmp2;
+			vel[n1 * 3 + n2] += tstep1 * tmpA * 0.5e-6;
+		}
+
+		vel[n1 * 3 + 0] += tstep1 * acc[n1 * 3 + 0] * 0.5e-6;
+		vel[n1 * 3 + 1] += tstep1 * acc[n1 * 3 + 1] * 0.5e-6;
+		vel[n1 * 3 + 2] += tstep1 * acc[n1 * 3 + 2] * 0.5e-6;
+		*/
+
+		f64 tstep1 = 0.5, tstep2 = tstep1 * tstep1;
+		f64 dcv    = tstep1 * previouse_velocity * 1.0e-3;
+		f64 dca    = tstep2 * previouse_acceleration * 0.5e-9;
+		f64 dc     = dcv + dca;
+
+		f64 dv1 = tstep1 * previouse_acceleration * 0.5e-6;
+		f64 dv2 = tstep1 * acceleration * 0.5e-6;
+		f64 dv  = dv1 + dv2;
+
+		f64 d_coordinate = coordinate - previouse_coordinate;
+		f64 d_velocity   = velocity   - previouse_velocity;
+
+		f64 d_coordinate_error = d_coordinate - dc;
+		f64 d_velocity_error   = d_velocity   - dv;
+
+		sum_d_coordinate_error += d_coordinate_error;
+		sum_d_velocity_error   += d_velocity_error;
+
+		if (loop  ==  max_frames - 1) {
+			printf("loop %d dc %0.06e = %0.06e (%0.06e + %0.06e) error=%0.06e %0.06e\n", loop
+				, d_coordinate
+				, dc
+				, dcv, dca
+				, d_coordinate_error
+				, d_velocity_error
+				);
+		}
+
+		f64 value = 0.0;
+		switch (crd_type)
+		{
+		case 0:
+			value = coordinate + 2 * shift * boundary[dim];
+			break;
+		case 1:
+			value = velocity;
+			break;
+		case 2:
+			value = acceleration;
+			break;
+		case 3:
+			value = force;
+			break;
+		case 4:
+			value = d_coordinate_error;
+			break;
+		case 5:
+			value = d_velocity_error;
+			break;
+		case 6:
+			value = sum_d_coordinate_error;
+			break;
+		case 7:
+			value = sum_d_velocity_error;
+			break;
+		case 8:
+			value = cumsum_velocity;
+			break;
+		case 9:
+			value = cumsum_acceleration;
+			break;
+		case 10:
+			value = cumsum_force;
+			break;
+
+		default:
+			break;
+		}
+
+		plot->AddData(loop, value);
+
+		mt_a1 = mt_a2 = mt_a3 = NULL;
+
+		previouse_coordinate   = coordinate;
+		previouse_velocity     = velocity;
+		previouse_acceleration = acceleration;
+
+		if (0 == loop)
+		{
+			first_coordinate = coordinate;
+		}
+	}
+
+	f64 mean_coordinate   = sum_coordinate   / max_frames;
+	f64 mean_velocity     = sum_velocity     / max_frames;
+	f64 mean_acceleration = sum_acceleration / max_frames;
+	f64 mean_force        = sum_force        / max_frames;
+
+	f64 mean_coordinate_per_time = mean_coordinate / this->time_step_between_traj_records;
+
+	f64 mean_d_coordinate_error = sum_d_coordinate_error / max_frames;
+	f64 mean_d_velocity_error   = sum_d_velocity_error   / max_frames;
+
+	printf("sum_d_coordinate_error / sum_coordinate %f\n", sum_d_coordinate_error / sum_coordinate);
+	printf("sum_coordinate - sum_d_coordinate_error %f\n", sum_coordinate - sum_d_coordinate_error);
+
+	printf("sum_coordinate  %f (nm)\n",  sum_coordinate);
+	printf("mean_coordinate %e (nm/frame)\n", mean_coordinate);
+
+	printf("sum_d_coordinate_error  %f \n",  sum_d_coordinate_error);
+	printf("mean_d_coordinate_error %e\n", mean_d_coordinate_error);
+
+	printf("sum_velocity  %f\n",  sum_velocity);
+	printf("mean_velocity %e [1.0e+3 m/s]\n", mean_velocity);
+	printf("mean_coordinate_per_time %e [nm/fs]\n", mean_coordinate_per_time);
+
+	printf("sum_d_velocity_error  %f\n",  sum_d_velocity_error);
+	printf("mean_d_velocity_error %e\n", mean_d_velocity_error);
+
+	printf("sum_acceleration  %f\n",  sum_acceleration);
+	printf("mean_acceleration %f\n", mean_acceleration);
+
+	printf("sum_force %f\n",  sum_force);
+	printf("mean_force %f\n", mean_force);
+
+	//printf("sum_%s %f\n",  crd_name[crd_type], sum_coordinate);
+	//printf("mean_%s %f\n", crd_name[crd_type], mean_coordinate);
+
+	plot->Finalize();
+	plot->GetWnd()->RequestUpdate(false);
+}
+
 void project::TrajView_CoordinatePlot(i32s inda, i32s dim)
 {
 	if (!this->GetTrajectoryFile())
@@ -3710,6 +4215,9 @@
 	float epot;
 	float tmp;
 
+	i32s shift = 0;
+	fGL previouse_coordinate = 0.0;
+
 	i32s max_frames = this->GetTotalFrames();
 	for (i32s loop = 0;loop < max_frames;loop++)
 	{
@@ -3724,9 +4232,9 @@
 		trajfile->read((char *) & ekin, sizeof(ekin));
 		trajfile->read((char *) & epot, sizeof(epot));
 
+		float boundary[3];
 		if (trajectory_version > 10)
 		{
-			float boundary[3];
 			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[0] = tmp;
 			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[1] = tmp;
 			trajfile->read((char *) & tmp, sizeof(tmp)); boundary[2] = tmp;
@@ -3806,10 +4314,22 @@
 		else
 			coordinate = 0;
 
-		f64 value = coordinate;
+		if (coordinate - previouse_coordinate > boundary[dim])
+		{
+			shift -= 1;
+			printf("coordinate %f- previouse_coordinate %f > boundary[dim] %f shift %d\n", coordinate, previouse_coordinate, boundary[dim], shift);
+		}
+		if (coordinate - previouse_coordinate < -boundary[dim])
+		{
+			shift += 1;
+			printf("coordinate %f- previouse_coordinate %f < boundary[dim] %f shift %d\n", coordinate, previouse_coordinate, boundary[dim], shift);
+		}
+
+		f64 value = coordinate + 2*shift*boundary[dim];
 		plot->AddData(loop, value);
 
 		mt_a1 = mt_a2 = mt_a3 = NULL;
+		previouse_coordinate = coordinate;
 	}
 
 	plot->Finalize();
diff -Nur ./ghemical-3.0.0.original/src/project.h ./ghemical-3.0.0/src/project.h
--- ./ghemical-3.0.0.original/src/project.h	2023-02-07 11:21:33.665100938 +0000
+++ ./ghemical-3.0.0/src/project.h	2023-02-07 16:25:52.680621680 +0000
@@ -376,6 +376,7 @@
 	void TrajView_VeloncityDistribution2D(i32s divx, i32s divy, f64 dt);
 	void TrajView_CoordinateDifferencePlot(i32s ind1, i32s ind2, i32s dim);
 	void TrajView_CoordinatePlot(i32s ind, i32s dim);
+	void TrajView_MoleculeCoordinatePlot(enum molgrouptype molgrouptype, i32s ind_mol, i32s dim, i32s crd_type);
 	void TrajView_DistancePlot(i32s inda, i32s indb);
 	void TrajView_AnglePlot(i32s inda, i32s indb, i32s indc);
 
